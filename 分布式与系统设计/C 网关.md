[TOC]

### 网关

#### 概述

##### 1. 什么是网关

**API 网关**可以看做系统与外界联通的入口，可以在网关进行处理一些非业务逻辑的逻辑，比如权限验证，监控，缓存，请求路由等等。

一般情况下，网关一般都会提供**请求转发、安全认证（身份/权限认证）、流量控制、负载均衡、容灾、日志、监控**等功能。实际上网关主要做了一件事情：**请求过滤** 。

##### 2. 网关用处

微服务下一个系统被**拆分为多个服务**，但是像**安全认证，流量控制，日志，监控**等功能是**每个服务都需要**的，没有网关的话，就需要在每个服务中**单独实现**，这就会做很多重复的事情并且没有一个全局的视图来统一管理这些功能。

- **RPC 协议转成 HTTP**。由于在内部开发中都是以 RPC 协议(thrift or dubbo)去做开发，暴露给内部服务，当**外部服务**需要使用这个**接口**的时候往往需要将 RPC 协议转换成 HTTP 协议。

- **请求路由**：一个系统可能同一个接口新老两套系统都在使用，需要需要根据请求上下文将请求路由到对应的接口。

- **统一鉴权**：对于**鉴权操作**不涉及到业务逻辑，那么可以在网关层进行处理，不用放到到业务逻辑层面。

- **统一监控**：由于网关是外部服务的**入口**，所以可以通过网关获取如**入参出参，链路时间**等监控信息。

- **流量控制，熔断降级**：对于流量控制，熔断降级**非业务逻辑**可以统一放到网关层。

##### 3. 常见网关系统

经常用到的开源 API 网关系统有：

1. **Kong**
2. **Netflix zuul**

可以看出不论是社区活跃度还是 Star数， Kong 都是略胜一筹。总的来说，**Kong 相比于 Zuul 更加强大并且简单易用**。Kong 基于 Openresty ，Zuul 基于 Java。

OpenResty（也称为 ngx_openresty）是一个全功能的 Web 应用服务器。它**打包了标准的 Nginx 核心**，很多的常用的第三方模块，以及它们的大多数依赖项。通过揉和众多设计良好的 Nginx 模块，OpenResty **有效地把 Nginx 服务器转变为一个强大的 Web 应用服务器**，基于它开发人员可以使用 Lua 编程语言对 Nginx 核心以及现有的各种 Nginx C 模块进行脚本编程，构建出可以处理一万以上并发请求的极端高性能的 Web 应用。另外， Kong 还提供了插件机制来扩展其功能。

比如、在服务上启用 Zipkin 插件：

```shell
$ curl -X POST http://kong:8001/services/{service}/plugins \
--data "name=zipkin" \
--data "config.http_endpoint \
		=http://your.zipkin.collector:9411/api/v2/spans" \
--data "config.sample_ratio=0.001"
```

##### 4. 统一API网关

**统一的 API 网关**不仅有 API 网关的所有的特点，还有下面几个好处：

**(1) 统一技术组件升级**：在公司中如果有某个技术组件需要升级，那么是需要和每个业务线沟通，通常几个月都搞不定。举个例子如果对于入口的安全鉴权有重大安全隐患需要升级，如果速度还是这么慢肯定是不行，那么有了统一的网关升级是很快的。

**(2) 统一服务接入**：对于某个服务的接入也比较困难，比如公司已经研发出了比较稳定的服务组件，正在公司大力推广，这个周期肯定也特别漫长，由于有了统一网关，那么只需要从网关统一接入。

**(3) 节约资源**：不同业务不同部门如果都自己搞一个网关层，那就太难受了。统一 API 网关可以节约资源。

#### 统一网关的设计

##### 1. 异步化请求

如果是自己实现的网关层，由于只有自己使用，对于吞吐量的要求并不高所以，一般**同步请求调用**即可。

对于统一的网关层，如何用少量的机器接入更多的服务，这就需要**异步化**用来提高更多的吞吐量。对于异步化一般有下面两种策略：

- **Tomcat/Jetty+NIO+servlet3**：这种策略使用的比较普遍，京东，有赞，Zuul，都选取的是这个策略，这种策略比较**适合 HTTP**。在 Servlet3 中可以开启异步。

- **Netty+NIO**：Netty 为高并发而生，目前唯品会的网关使用这个策略，在唯品会的技术文章中在相同的情况下 Netty 是每秒 30w+ 的吞吐量，Tomcat 是 13w+，可以看出是有一定的差距的，但是 Netty 需要自己处理 HTTP 协议，这一块比较麻烦。

对于网关是 HTTP 请求场景比较多的情况可以**采用 Servlet**，毕竟有更加成熟的处理 HTTP 协议。如果更加**重视吞吐量**那么可以采用 **Netty**。

###### (1) 全链路异步

对于来的**请求已经使用异步**了，为了达到**全链路异步**所以需要对**去的请求**也进行异步处理，对于去的请求可以利用 **RPC 的异步支持**进行异步请求，所以基本可以达到下图：


![](assets/166c877315e557af)

由在 web 容器中开启 **servlet 异步**，然后进入到**网关的业务线程池中进行业务处理**，然后进行 RPC 的**异步调用并注册需要回调的业务**，最后在回调线程池中进行回调处理。

##### 2. 链式处理

在设计模式中有一个模式叫**责任链模式**，其作用是避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。通过这种模式将请求的发送者和请求的处理者解耦了。各个框架中对此模式都有体现，比如 servlet 里面的 filter，Spring MVC 里面的 Interceptor。

在 **Netflix Zuul** 中也应用了这种模式，如下图所示：

![](assets/166c878240753735)

可以借鉴这种设计模式到自己的网关设计中：

- **preFilters**：**前置过滤器**，用来处理一些公共的业务，比如**统一鉴权，统一限流，熔断降级，缓存处理**等，并且提供业务方扩展。

- **routingFilters**：用来处理一些**泛化调用**，主要是做**协议的转换，请求的路由**工作。

- **postFilters**：后置过滤器，主要用来做**结果的处理，日志打点，记录时间**等等。

- **errorFilters**：错误过滤器，用来**处理调用异常**的情况。

这种设计在有赞的网关也有应用。

##### 3. 业务隔离

上面在**全链路异步**的情况下**不同业务之间的影响很小**，但是如果在提供的自定义 FiIlter 中进行了某些**同步调用**，一旦超时频繁那么就会对其他业务产生影响。所以**需要采用隔离之术，降低业务之间的互相影响**。

###### (1) 信号量隔离

信号量隔离只是**限制了总的并发数**，服务还是主线程进行**同步调用**。这个隔离如果远程调用超时依然会影响主线程，从而会影响其他业务。因此，如果只是想限制某个服务的总并发调用量或者调用的服务不涉及远程调用的话，可以使用**轻量级的信号量**来实现。有赞的网关由于没有自定义 filter 所以选取的是信号量隔离。

###### (2) 线程池隔离

最简单的就是**不同业务之间通过不同的线程池进行隔离**，就算业务接口出现了问题由于线程池已经进行了隔离那么也不会影响其他业务。在京东的网关实现之中就是采用的线程池隔离，比较重要的业务比如商品或者订单都是**单独的通过线程池去处理**。但是由于是**统一网关平台**，如果业务线众多，大家都觉得自己的业务比较重要需要单独的线程池隔离，如果使用的是 Java 语言开发的话那么在 Java 中线程是比较重的资源比较受限，如果需要隔离的线程池过多不是很适用。如果使用一些其他语言比如 Golang 进行**开发网关**的话，线程是比较轻的资源，所以**比较适合使用线程池隔离**。

###### (3) 集群隔离

如果有某些业务就需要使用隔离但是统一网关又没有线程池隔离那么应该怎么办呢？那么可以使用**集群隔离**，如果某些业务真的很重要那么可以为这一系列业务单独申请一个集群或者多个集群，通过机器之间进行隔离。

##### 4. 请求限流

**流量控制**可以采用很多开源的实现，比如阿里最近开源的 **Sentinel** 和比较成熟的 **Hystrix**。一般限流分为**集群限流**和**单机限流**:

- 利用**统一存储**保存**当前流量的情况**，一般可以采用 Redis，这个一般会有一些性能损耗。
- 单机限流：**限流每台机器**可以直接利用 Guava 的**令牌桶**去做，由于没有远程调用所以性能消耗较小。

##### 2.5 熔断降级

可以参照开源的实现 **Sentinel** 和 **Hystrix**。

##### 2.6 泛化调用

**泛化调用**指的是一些**通信协议的转换**，比如将 HTTP 转换成 Thrift。在一些开源的网关中比如 Zuul 是没有实现的，因为各个公司的**内部服务通信协议都不同**。比如在唯品会中支持 HTTP1,HTTP2 以及二进制的协议，然后转化成**内部的协议**，淘宝的支持 HTTPS,HTTP1,HTTP2 这些协议都可以转换成，HTTP, HSF, **Dubbo** 等协议。

###### (1) 泛化调用

如何实现**泛化调用**？由于协议很难自动转换，那么其实**每个协议对应的接口需要提供一种映射**。简单来说就是**把两个协议都能转换成共同语言，从而互相转换**。

<img src="assets/166c880ac8bdb575" style="zoom:40%;" />

一般来说**共同语言**有三种方式指定：

- **JSON**：JSON 数据格式比较简单，解析速度快，较轻量级。在 Dubbo 的生态中有一个 **HTTP 转 Dubbo** 的项目是用 JsonRpc 做的，将 HTTP 转化成 JsonRpc 再转化成 Dubbo。比如可以将一个 HTTP 请求：http://www.baidu.com?id = 1 映射为 JSON：

```json
{
    “method”: "getBaidu"
    "param" : {
    "id" : 1
	}
}
```

- **XML**：XML 数据比较重，解析比较困难，不过多讨论。

- **自定义描述语言**：一般来说这个成本比较高需要自己定义语言来进行描述并进行解析，但是其扩展性，自定义个性化性都是最高。比如 Spring 自定义了一套自己的 SpEL 表达式语言。

对于泛化调用如果要自己设计的话 **JSON 基本可以满足**，如果对于个性化的需要特别多的话倒是可以自己定义一套语言。

##### 2.7 管理平台

上面介绍的都是**如何实现一个网关**的技术关键。这里需要介绍网关的一个业务关键。有了网关之后，需要一个管理平台去对上面所描述的技术关键进行**配置**，包括但不限于下面这些配置：限流、熔断、缓存、日志、自定义 filter、泛化调用等。

#### 总结

##### 1. 统一网关架构总结

最后总结一个合理的标准网关应该按照如下去实现：

![](assets/166c88416c4cc227)

##### 2. 大厂网关实现总结

| 公司     |      京东      |            唯品会             |                          有赞                          |                             阿里                             |                             Zuul                             |
| -------- | :------------: | :---------------------------: | :----------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 实现关键 | **servlet3.0** |           **Netty**           |                     **servlet3.0**                     |                        **servlet3.0**                        |                        **servlet3.0**                        |
| 异步情况 |  servlet 异步  |        **全链路异步**         |                     **全链路异步**                     |                        **全链路异步**                        |               Zuul1 同步阻塞，Zuul2 异步非阻塞               |
| 限流     |      ---       |              ---              | 平滑限流。最初是 codis，后续换到每个单机的令牌桶限流。 | 1.基本流控：基于 API 的QPS做限流。2.运营流控:支持APP流量包，APP+API+USER的流控33.大促流控:APP访问API的权重流控。阿里开源:Sentinel | 提供了jar包:spring-cloud-zuul-ratelimit。1.对请求的目标URL进行限流（例如：某个URL每分钟只允许调用多少次)。2.对客户端的访问IP进行限流（例如：某个IP每分钟只允许请求多少次）3.对某些特定用户或者用户组进行限流（例如：非VIP用户限制每分钟只允许调用100次某个API等）4.多维度混合的限流。此时，就需要实现一些限流规则的编排机制。与、或、非等关系。支持四种存储方式ConcurrentHashMap,Consul,Redis,数据库。 |
| 熔断降级 |      ---       |              ---              |                      **Hystrix**                       |                             ---                              |             只支持服务级别熔断，不支持URL级别。              |
| 隔离     |   线程池隔离   |              ---              |                     **信号量隔离**                     |                             ---                              |                  **线程池隔离，信号量隔离**                  |
| 缓存     |     redis      |              ---              |                二级缓存，本地缓存+Codis                |               HDCC 本地缓存，远程缓存，数据库                |                         需要自己开发                         |
| 泛化调用 |      ---       | http,https,http1,http2,二进制 |                    dubbo,http,nova                     |               hsf,dubbo,http,https,http2,http1               |                         只支持 http                          |



#### 参考资料

- 京东：http://www.yunweipai.com/archives/23653.html

- 有赞网关：https://tech.youzan.com/api-gateway-in-practice/

- 唯品会：https://mp.weixin.qq.com/s/gREMe-G7nqNJJLzbZ3ed3A

- Zuul：http://www.scienjus.com/api-gateway-and-netflix-zuul/

