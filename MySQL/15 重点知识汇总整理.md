### 1. 聚集索引与非聚集索引

### 2. B树、B+树、红黑树

### 3. 事务四大特性(ACID)：原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)、持久性(Durability)

### 4. 并发一致性问题：丢失修改、脏读、不可重复读、幻读

### 5. 事务隔离级别：读未提交、读已提交、可重复读、可串行化

### 6. 封锁类型：读写锁(排它锁也叫写锁X，共享锁也叫读锁S)、意向锁(便于支持多粒度封锁)

### 7. 封锁协议：三级封锁协议、两段锁协议
#### 三级封锁协议
- 一级封锁协议：事务T修改数据时必须加X锁，直到T结束才释放锁，解决**丢失修改**问题
- 二级封锁协议：一级的基础上，要求读取数据A时必须加S锁，读取完立即释放，解决脏读问题，但是不能解决不可重复读问题
- 三级封锁协议：在二级的基础上，要求读取数据A时必须加S锁，直到事务结束才释放S锁，解决不可重复读问题

#### 两段锁协议
加锁和释放锁分两个阶段进行

### 8. 锁算法
- Record lock：单个行记录上的锁
- Gap lock：间隙锁，锁定一个范围，不包括记录本身
- Next-key lock：record+gap 锁定一个范围，包括记录本身

### 9. 多版本并发控制MVCC(Mutil-Version Concurrency Control)
- 用于实现隔离级别的一种具体方式，实现**读已提交**和**可重复读**
- 读未提交隔离级别总是读取最新数据行，无需MVCC
- 可串行化需要对所有读取行加锁，单纯MVCC无法实现

#### 9.1 版本号
- 系统版本号：每开始一个新的事务，系统版本号就会递增
- 事务版本号：事务开始时的系统版本号
#### 9.2 隐藏的列
MVCC每行记录后面都隐藏两个列，用来存储两个版本号：
- 创建版本号：创建一个数据行的快照时的系统版本号
- 删除版本号：如果该快照的删除版本号大于当前事务版本号则快照有效，否则表示该快照已经删除
#### 9.3 Undo日志
MVCC使用的快照存储在Undo日志中，通过回滚指针把一个数据行的所有快照连接在一起
#### 9.4 可重复读的实现过程
PS：**当开始一个事务时，该事务的版本号大于当前所有数据行快照的版本号**
1. SELECT   
     多个事务必须读取到同一个数据行的快照，且该快照是距离现在最近的一个有效快照。但如果有一个事务正在修改该数据行，那它可以读取事务本身所做的修改。
    事务T读取的删除版本号必须大于T的版本号
2. INSERT    
      将当前系统版本号作为数据行快照的创建版本号，旧数据不是删除而是清理，即InnoDB开启一个后台线程进行清理，将删除版本号小于当前系统版本的行删除(purge)
3. DELETE   
      将当前系统版本号作为数据行快照的删除版本号
4. UPDATE    
      将当前系统版本号作为更新前的数据行快照的删除版本号，同时作为更新后数据行快照的创建版本号，理解为先DELETE，再INSERT
#### 9.5 快照读与当前读
##### 快照读
使用MVCC读取的是快照中的数据，可以减少加锁带来的开销
MVCC使用可以解决快照读的幻读问题，因为事务A只能读取最接近的一个版本号的快照，而此时新的事务B所插入的数据版本号会高于A，A再次读取也不会读取到
##### 当前读
读取最新的数据，需要加锁

### 10. Next-Key Locks
MySQL默认的隔离级别是repeatable-read,有办法解决幻读问题吗？

Next-Key Locks是MySQL的InnoDB存储引擎的一种锁实现

#### 10.1 Record Locks(行锁)
单条索引记录上加锁，record lock锁住的永远是索引，而非记录本身，即使该表上没有任何索引，那么innodb会在后台创建一个隐藏的聚集主键索引，
那么锁住的就是这个隐藏的聚集主键索引。所以说当一条sql没有走任何索引时，那么将会在每一条聚集索引后面加X锁，这个类似于表锁，
但原理上和表锁应该是完全不同的。
#### 10.2 Gap Locks(间隙锁)
在索引记录之间的间隙中加锁，或者是在某一条索引记录之前或者之后加锁，并不包括该索引记录本身。gap lock的机制主要是解决可重复读模式下的幻读问题
#### 10.3 Next-Key Locks
是二者的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙，锁定间隙就可以防止某些情况下的幻读

### 11. 死锁
指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。
此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。

### 12. 锁分类
性能上分为：乐观锁和悲观锁
对数据库操作类型分：读锁和写锁
对数据库操作的粒度分：表锁和行锁
#### 12.1 乐观锁

#### 12.2 悲观锁

### 13. MySQL优化
#### 13.1 查询性能优化
##### 13.1.1 使用Explain进行分析

##### 13.1.2 优化数据访问
1. 减少请求的数据量
  - 只返回必要的列：最好不要用SELECT \*语句
  - 只返回必要的行，使用LIMIT语句来限制
  - 缓存重复查询的数据
2. 减少服务端扫描的行数
  - 最有效的方式是使用索引来覆盖查询
##### 13.1.3 重构查询方式
1. 切分大查询   
  一个大查询一次性执行的话会锁住很多资源，阻塞很多小查询
2. 分解大连接查询   
  将一个大连接查询分解成对每一个表进行一次单表查询，然后在应用程序中进行关联，这样的优势：
  - 让缓存更高效。对于连接查询，如果一个表发生变化，那么整个查询缓存就无法使用。而分解的多个查询，及时其中一个表发生变化，对其他表的查询依然可以进行
  - 分解成多个单表查询。这些单表查询的缓存结果可能被其他查询用到，从而减少冗余记录的查询
  - 减少锁竞争
  - 在应用层进行连接。可以更容易对数据库进行拆分，从而做到高性能和可伸缩
  - 灵活使用语句，提高本省的查询效率

#### 13.2 大表优化
##### 13.2.1 限定数据的范围
禁止不带任何限数据范围条件的查询语句

##### 13.2.2 读/写分离
数据库拆分，主库写，从库读

##### 13.2.3 垂直分区
根据数据库里数据表的相关性进行拆分。即数据表列的拆分。

##### 13.2.4 水平分区
保持数据表结构不变，通过某种策略储存数据分片，每一片数据分散到不同的表或者库中，达到分布式的目的。


### 14. MySQL复制
#### 14.1 主从复制
##### 14.1.1 复制步骤
1. master记录更改的明细，存入二进制文件(binary log)，如记录增删改的过程，不记录查询的过程
2. master发送同步消息给slave
3. slave收到消息后，将master的二进制日志复制到本地的中继日志(relay log)
4. slave重现中继日志中的消息，从而改变数据库的数据

主要涉及三个线程，binlog、I/O、SQL线程
- binlog线程：负责将主服务器的更改写入二进制日志(Binary log)中
- I/O线程：负责从主服务器上读取二进制文件，并写入从服务器的中继日志(Relay log)中
- SQL线程：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中执行

##### 14.1.2 日志
MySQL复制的日志格式有三种，根据主库存放数据的方式的不同有以下三种，对应三种复制方式：

复制方式|特点|优点|缺点
--|:--:|:--:|--
row|基于行的格式复制，记录需要修改的每行的数据信息|保证了数据的强一致性，且由于记录的是执行后的结果，在从库上执行还原也会比较快|日志记录数量多，日志文件巨大，主从间传输需要更多时间
statement|基于段的日志格式复制，也就是记录下更改的SQL的记录，而不是更改的行的记录|日志记录量最小|对于一些输出结果不稳定的函数，在从库上执行一遍很可能会出现问题，如UUID，从库根据日志还原主库数据需要执行一遍SQL，时间相对较慢
mixed|混合上面两种记录格式，何时使用哪个由MySQL决定|平衡两种日志的优缺点|

##### 14.1.3 复制方式
- 异步复制：主库写入一个事务commit提交并执行完之后，将日志记录到binlog，将结果反馈给客户端，最后将日志传输到从库。该复制常见问题：因为binlog日志是推送的，所有主库和从库之间存在一定的延迟。会造成很多问题：比如主库因为磁盘损坏等故障突然崩溃，导致binlog日志不存在，同时因为还没有推送到从库，从库就会丢失很多主库已经提交的事务，造成主从不一致。

- 半同步复制：主库写入一个事务commit提交并执行完之后，并不直接将请求反馈给前端应用用户，而是等待从库也接受到binlog日志并成功写入中继日志之后，主库才返回commit操作成功给客户端。保障了事务执行后，至少有两份日志记录，保证数据的一致性。

#### 14.2 读写分离
主服务器处理写操作以及实时性要求高的读操作，从服务器处理读操作

提升性能：
- 主从服务器负责各自的读写，极大程度缓解了锁的竞争；
- 从服务器可以使用MyISAM，提升查询性能以及节约系统开销；
- 增加冗余，提高可用性

读写分离常用代理方式实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器

### 15. MySQL主从同步延时解决
- 分库，将一个主库拆分为多个主库，每个主库的写并发就减少了几倍，此时主从延迟可忽略不计；
- 打开MySQL支持的并行复制，多个库并行复制。如果说某个库的写入并发就是特别高，单库写并发很高，2000/s，并行复制还是没有意义；
- 重写代码，代码要注意，插入数据时立马查询可能查不到；
- 如果必须插入后立即可查询，可将查询设置直连主库。
