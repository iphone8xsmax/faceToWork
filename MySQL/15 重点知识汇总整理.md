### 1. 聚集索引与非聚集索引

### 2. B树、B+树、红黑树

### 3. 事务四大特性(ACID)：原子性(Atomicity)、一致性(Consistency)、隔离性(Isolation)、持久性(Durability)

### 4. 并发一致性问题：丢失修改、脏读、不可重复读、幻读

### 5. 事务隔离级别：读未提交、读已提交、可重复读、可串行化

### 6. 封锁类型：读写锁(排它锁也叫写锁X，共享锁也叫读锁S)、意向锁(便于支持多粒度封锁)

### 7. 封锁协议：三级封锁协议、两段锁协议
#### 三级封锁协议
    - 一级封锁协议：事务T修改数据时必须加X锁，直到T结束才释放锁，解决**丢失修改**问题
    - 二级封锁协议：一级的基础上，要求读取数据A时必须加S锁，读取完立即释放，解决脏读问题，但是不能解决不可重复读问题
    - 三级封锁协议：在二级的基础上，要求读取数据A时必须加S锁，直到事务结束才释放S锁，解决不可重复读问题

#### 两段锁协议
    加锁和释放锁分两个阶段进行

### 8. 锁算法
    - Record lock：单个行记录上的锁
    - Gap lock：间隙锁，锁定一个范围，不包括记录本身
    - Next-key lock：record+gap 锁定一个范围，包括记录本身

### 9. 多版本并发控制MVCC(Mutil-Version Concurrency Control)
    - 用于实现隔离级别的一种具体方式，实现**读已提交**和**可重复读**
    - 读未提交隔离级别总是读取最新数据行，无需MVCC
    - 可串行化需要对所有读取行加锁，单纯MVCC无法实现

#### 9.1 版本号
    - 系统版本号：每开始一个新的事务，系统版本号就会递增
    - 事务版本号：事务开始时的系统版本号
#### 9.2 隐藏的列
    MVCC每行记录后面都隐藏两个列，用来存储两个版本号：
    - 创建版本号：创建一个数据行的快照时的系统版本号
    - 删除版本号：如果该快照的删除版本号大于当前事务版本号则快照有效，否则表示该快照已经删除
#### 9.3 Undo日志
    MVCC使用的快照存储在Undo日志中，通过回滚指针把一个数据行的所有快照连接在一起
#### 9.4 可重复读的实现过程
    PS：**当开始一个事务时，该事务的版本号大于当前所有数据行快照的版本号**
    1. SELECT
      多个事务必须读取到同一个数据行的快照，且该快照是距离现在最近的一个有效快照。但如果有一个事务正在修改该数据行，那它可以读取事务本身所做的修改。
      事务T读取的删除版本号必须大于T的版本号
    2. INSERT
      将当前系统版本号作为数据行快照的创建版本号，旧数据不是删除而是清理，即InnoDB开启一个后台线程进行清理，将删除版本号小于当前系统版本的行删除(purge)
    3. DELETE
      将当前系统版本号作为数据行快照的删除版本号
    4. UPDATE
      将当前系统版本号作为更新前的数据行快照的删除版本号，同时作为更新后数据行快照的创建版本号，理解为先DELETE，再INSERT
#### 9.5 快照读与当前读
##### 快照读
      使用MVCC读取的是快照中的数据，可以减少加锁带来的开销
      MVCC使用可以解决快照读的幻读问题，因为事务A只能读取最接近的一个版本号的快照，而此时新的事务B所插入的数据版本号会高于A，A再次读取也不会读取到
##### 当前读
      读取最新的数据，需要加锁

### 10. Next-Key Locks
    MySQL默认的隔离级别是repeatable-read,有办法解决幻读问题吗？

    Next-Key Locks是MySQL的InnoDB存储引擎的一种锁实现

#### 10.1 Record Locks(行锁)
    单条索引记录上加锁，record lock锁住的永远是索引，而非记录本身，即使该表上没有任何索引，那么innodb会在后台创建一个隐藏的聚集主键索引，
    那么锁住的就是这个隐藏的聚集主键索引。所以说当一条sql没有走任何索引时，那么将会在每一条聚集索引后面加X锁，这个类似于表锁，
    但原理上和表锁应该是完全不同的。
#### 10.2 Gap Locks(间隙锁)
    在索引记录之间的间隙中加锁，或者是在某一条索引记录之前或者之后加锁，并不包括该索引记录本身。gap lock的机制主要是解决可重复读模式下的幻读问题
#### 10.3 Next-Key Locks
    是二者的结合，不仅锁定一个记录上的索引，也锁定索引之间的间隙，锁定间隙就可以防止某些情况下的幻读

### 11. 死锁
    指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。
    此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。

### 12. 锁分类
    性能上分为：乐观锁和悲观锁
    对数据库操作类型分：读锁和写锁
    对数据库操作的粒度分：表锁和行锁
#### 12.1 乐观锁

#### 12.2 悲观锁
