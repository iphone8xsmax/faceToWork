[TOC]

### MySQL锁机制

#### 锁定义

锁是计算机协调多个进程或线程并发访问某一资源的机制。
在数据库中，除了传统的计算资源（如 CPU、RAM、I/O 等）的争用以外，数据也是一种供需要用户共享的资源。如何保证数据并发访问的一致性、有效性是所有数据库必须解决的一个问题，锁冲突也是影响数据库并发访问性能的一个重要因素。

#### 锁分类

从性能上分为**乐观锁**(用版本对比来实现)和**悲观锁**，从对数据库操作的类型分，分为**读锁**和**写锁**(都属于悲观锁)。

- **读锁**（共享锁）：针对同一份数据，多个读操作可以同时进行而不会互相影响。
- **写锁**（排它锁）：当前写操作没有完成前，它会阻断其他写锁和读锁。

- 从对数据操作的粒度分，分为**表锁和行锁**。

##### 1. 表锁

每次操作**锁住整张表**。开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低；  

来个表格。注意**引擎为 MyISAM**。

```mysql
CREATE TABLE `mylock` (
    `id` INT (11) NOT NULL AUTO_INCREMENT,
    `NAME` VARCHAR (20) DEFAULT NULL,
    PRIMARY KEY (`id`)
) ENGINE = MyISAM DEFAULT CHARSET = utf8;

# 插入数据
INSERT INTO`test`.`mylock` (`id`, `NAME`) VALUES ('1', 'a');
INSERT INTO`test`.`mylock` (`id`, `NAME`) VALUES ('2', 'b');
INSERT INTO`test`.`mylock` (`id`, `NAME`) VALUES ('3', 'c');
INSERT INTO`test`.`mylock` (`id`, `NAME`) VALUES ('4', 'd');
```

- 手动增加表锁：lock table 表名称 read(write), 表名称2 read(write);
- 查看表上加过的锁：show open tables; 如果 inuse 字段为 1，说明这个表已经加锁了。
- 删除表锁：unlock tables;  

**加读锁**：当前 session 和其他 session 都可以读该表，当前 session 中插入或者更新锁定的表都会报错，其他 session 插入或更新则会等待。

```mysql
lock table myLock read;
```

**加写锁**：当前 session 对该表的增删改查都没有问题，**其他** session 对该表的**所有操作被阻塞**。 

```mysql
lock table myLock write;
```

**MyISAM 在执行==查询==语句(SELECT)前，会自动给涉及的所有表==加读锁==，在执行==增删改==操作前，会自动给涉及的表加==写锁==。**

1、对 MyISAM 表的读操作(加读锁) ,不会阻寒其他进程对同一表的读请求,但会阻赛对同一表的写请求。只有当读锁释放后,才会执行其它进程的写操作。
2、对 MylSAM 表的写操作(加写锁) ,会阻塞其他进程对同一表的读和写操作,只有当写锁释放后,才会执行其它进程的读写操作。

数据迁移的时候，可以加一个表锁。

总结：==**读锁会阻塞写，但是不会阻塞读。而写锁则会把读和写都阻塞**。==  

##### 2. 行锁

每次操作**锁住一行数据**。开销大，加锁慢；会出现**死锁**；锁定粒度最小，发生锁冲突的概率最低，并发度最高。  

InnoDB 与 MYISAM 的最大不同有两点：

- 支持事务（TRANSACTION）
- 支持行级锁  

###### (1) 事务（Transaction）及ACID

行锁支持事务。

事务是由一组 SQL 语句组成的逻辑处理单元，事务具有以下 4 个属性，通常简称为**事务的 ACID 属性**。

- **原子性**(Atomicity) ：事务是一个原子操作单元，其对数据的修改，要么全都执行，要么全都不执行。
- **一致性**(Consistent) ：在**事务开始和完成**时，**数据都必须保持一致状态**。这意味着所有相关的数据规则都必须应用于事务的修改，以保持数据的完整性；事务结束时，所有的内部数据结构(如B树索引或双向链表)也都必须是正确的。
- **隔离性**(Isolation) ：数据库系统提供一定的隔离机制，保证事务**在不受外部并发操作影响的“独立”环境执行**。这意味着事务处理过程中的中间状态对外部是**不可见**的，反之亦然。
- **持久性**(Durable) ：事务完成之后，它对于数据的修改是永久性的，即使出现系统故障也能够保持。  

###### (2) 并发事务的问题

**更新丢失（Lost Update）**

当两个或多个事务选择**同一行**，然后基于最初选定的值更新该行时，由于每个事务都**不知道**其他事务的存在，就会发生丢失更新问题：**A 事务的更新==覆盖==了由其他事务所做的更新**。

**脏读（Dirty Reads）**

一个事务**正在**对一条记录做修改，在这个事务完成并**提交前**，这条记录的数据就处于**不一致**的状态；这时，另一个事务也来读取**同一条记录**，如果不加控制，第二个事务读取了这些“**脏”数据**，并据此作进一步的处理，就会产生未提交的数据依赖关系。这种现象被形象的叫做“**脏读”**。
一句话：**事务 A 读取到了事务 B 已经修改但尚未提交的数据**，还在这个数据基础上做了**操作**。此时，如果 B 事务不提交而进行**回滚**，则 A 读取的数据无效，不符合一致性要求。

**不可重读（Non-Repeatable Reads）**
一个事务在读取某些数据后的某个时间，再次读取以前读过的数据，却发现其读出的数据已经发生了改变、或某些记录已经被删除了！这种现象就叫做“不可重复读”。
一句话：事务 A 读取到了事务 B **已经提交**的修改数据，不符合隔离性。比如 A 

**幻读（Phantom Reads）**
一个事务按相同的查询条件重新读取以前检索过的数据，却发现其他事务插入了满足其查询条件的新数据，这种现象就称为“幻读”。
一句话：事务 A 读取到了事务 B **提交的新增数据**，不符合隔离性。  

###### (3) 事务隔离级别

脏读”、“不可重复读”和“幻读”，其实都是数据库读**一致性问题**，必须由数据库提供一定的事务隔离机制来解决。  

数据库的事务隔离越严格，并发副作用越小，但付出的代价也就越大，因为事务隔离实质上就是使事务在一定程度上“串行化”进行，这显然与“并发”是矛盾的。
同时，不同的应用对读一致性和事务隔离程度的要求也是不同的，比如许多应用对“不可重复读"和“幻读”并不敏感，可能更关心数据并发访问的能力。

**常看**当前数据库的事务隔离级别: **show variables like 'tx_isolation'**;

**设置**事务隔离级别：**set tx_isolation='REPEATABLE-READ'**;  

每个**会话都有自己的事务隔离级别**。不同的**连接**可以设置不同的隔离级别。

###### (4) 演示分析

建表：

```mysql
CREATE TABLE `account` (
    `id` int(11) NOT NULL AUTO_INCREMENT,
    `name` varchar(255) DEFAULT NULL,
    `balance` int(11) DEFAULT NULL,
    PRIMARY KEY (`id`)6 ) ENGINE=InnoDB DEFAULT CHARSET=utf8;
INSERT INTO `test`.`account` (`name`, `balance`) VALUES ('lilei', '450');
INSERT INTO `test`.`account` (`name`, `balance`) VALUES ('hanmei', '16000');
INSERT INTO `test`.`account` (`name`, `balance`) VALUES ('lucy', '2400');
```





