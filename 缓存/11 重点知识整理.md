# 1. 缓存基本特征
## 1.1 命中率
缓存命中：某个请求能够通过访问缓存得到相应
## 1.2 最大空间
缓存通常位于内存中，比磁盘空间要小很多，最大空间不可能很大，当超过最大空间需要进行部分缓存数据淘汰
## 1.3 缓存淘汰(更新)策略
### 1.3.1 FIFO/LRU/LFU算法剔除
剔除算法常用于缓存使用量超过预设最大值的时候。Redis使用maxmemory-policy参数设置剔除策略。
1. FIFO先进先出策略(First In First Out)
在实时性的场景下，需要经常访问最新的数据，就可使用这个策略。
2. LRU最近最久未使用策略(Least Recently Used)
优先淘汰最久未使用的数据。可以保证缓存中都是热点数据，也就是经常被访问的数据，从而保证缓存命中率
3. LFU最不经常使用策略(Least Frequently Used)
优先淘汰一段时间内使用次数最少的数据

### 1.3.2 超时剔除
给缓存设置超时时间，过期自动删除，如Redis中的expire命令

### 1.3.3 主动更新
对于高一致性要求场景，需要在真实数据更新后，立即更新缓存

# 2. 缓存位置
1. 浏览器：当HTTP响应允许进行缓存时，浏览器会将HTML,CSS,JS,图片等静态资源缓存
2. ISP: 网络服务提供商(ISP)是网络访问的第一跳，通过将数据缓存在ISP能大大提高用户访问速度
3. 反向代理：反向代理位于服务器之前
4. 本地缓存
5. 分布式缓存
6. 数据库缓存
7. 程序内部缓存
8. CPU多级缓存

# 3. CDN
内容分发网络(Content distribution network)是一种互连的网络系统，利用更靠近用户的服务器将静态资源更快更可靠的分发给用户。

# 4. 缓存问题

## 4.1 缓存穿透
对一个一定不存在的数据进行请求，就会穿透缓存到达数据库
### 4.1.1 解决方案
首先可以在应用层记录一下缓存穿透的次数，方便问题查找与预警
- 参数校验
最基本就是做好参数校验，不合法的参数直接返回异常信息给客户端
- 缓存无效的key
如果缓存和数据库都查不到某个key的数据就写一个这个键的空对象到Redis中并设置过期时间；
可以解决请求的key变化不频繁的情况，但如果每次构建不同的请求key，会缓存大量无效的key，如果一定要用，将过期时间设置的短一些。
- 使用布隆过滤器
判断key是否合法。把所有可能存在的请求的值都放在布隆过滤器中，判断用户请求是否存在于过滤器中。
适用于数据命中率不高、数据相对固定、实时性低（通常是数据集大）的场景。

## 4.2 缓存雪崩
由于数据没有加载到缓存中，或者缓存数据同一时间大面积失效（过期），又或者缓存服务器宕机，导致大量请求到达数据库
### 4.2.1 解决方案
- 为了防止缓存在同一时间大面积过期导致的缓存雪崩，可以通过**观察用户行为**，合理设置**缓存过期时间**来实现；
- 为了防止缓存服务器宕机出现的缓存雪崩，可以使用**分布式缓存**，保证**缓冲层的高可用**。分布式缓存中每一个节点只缓存部分的数据，当某个节点宕机时可以保证其它节点的缓存仍然可用，实现**高可用**。
- 也可以进行**缓存预热**，提前放一些数据到缓存中，避免在系统刚启动不久由于还未将大量数据进行缓存而导致缓存雪崩。
- **依赖隔离组件为后端限流并降级**。可以考虑进行服务降级，并对重要的资源进行**隔离**。
按时间节点来讲：
- **事前**：尽量保证整个 Redis 集群的**高可用性**，发现机器宕机尽快补上。选择合适的**内存淘汰策略**。
- **事中**：**本地 Ehcache 缓存** + **hystrix 限流&降级**，避免 MySQL 崩掉。
- **事后**：利用 Redis **持久化**机制保存的数据**尽快恢复缓存**。

## 4.3 缓存一致性问题
缓存层和存储层的数据存在着一定时间窗口的不一致性。缓存一致性要求数据**更新的同时缓存数据也能够实时更新**。
### 4.3.1 解决方案
- 在数据更新的同时立即去更新缓存，一致性最高
- 在读缓存之前先判断缓存是否最新的，如果不是则先更新

## 4.4 缓存“无底洞”问题
为了满足业务要求添加了大量缓存节点，但是性能不但没有好转反而下降的现象。

**产生原因：**缓存系统通常采用hash函数将key映射到对应的缓存节点，随着缓存节点数目的增加，键值分布到更多的节点上，导致客户端一次批量操作会涉及**多次网络操作**，这意味着批量操作的耗时会随着节点数目的增加而不断增大。此外网络连接数变多，对节点的性能也有一定影响。
### 4.4.1 解决方案
- 优化批量数据操作命令
- 减少网络通信次数
- 降低接入成本，使用长连接/连接池，NIO等

分布式条件下，以Redis的mget指令为例，有四种批量操作解决方案：
- 串行命令。逐次执行n个get命令
- 串行IO
- 并行IO
- hash_tag实现，可以强制将多个key强制分配到一个节点上，减少操作

# 5. 数据分布
## 5.1 哈希分布
数据计算哈希值后，按照哈希分配到不同的节点上，hash(key)%N
存在问题：数据需要重新分布(再哈希)，可能导致大量数据迁移
## 5.2 顺序分布
顺序分布的优势：
- 能保持原有顺序
- 并且能够准确控制每台服务器存储的数据量，使得存储空间利用率最大

# 6. 一致性哈希
Distributed Hash Table(DHT)：其目的是为了克服传统哈希分布在服务器节点数量变化再哈希时大量数据迁移的问题
## 6.1 基本原理
将哈希空间看做一个哈希环。每个数据对象通过哈希取模得到哈希值之后，存放到哈希环中顺时针方向第一个大于等于该哈希值的节点上。
一致性哈希在增加或者删除节点时只会影响到哈希环中相邻的节点
## 6.2 虚拟节点
一致性哈希存在数据分布不均的情况，主要是因为节点在哈希环分布的不均匀。
可以通过增加虚拟节点解决，将虚拟节点映射到真实节点上

# 7. 缓存实现
## 7.1 本地缓存
自带的map等数据结构，在多实例情况下，每个实例都各自保存一份缓存，具有不一致性
## 7.2 分布式缓存
使用Redis或memcached的，在多实例情况下，每个实例共用一份缓存数据，缓存具有一致性。
