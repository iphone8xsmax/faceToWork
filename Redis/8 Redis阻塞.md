[TOC]

### Redis阻塞

Redis 是单线程架构，阻塞起来很难受啊，这里总结一下可能导致 Redis 阻塞的情况。

主要分为内在原因和外在原因。

内在原因：不合理的使用 API 或数据结构、CPU 饱和、持久化阻塞等。

外在原因：CPU 竞争、内存交换、网络问题等。



#### 阻塞发现

如何发现阻塞问题？

先寻找是不是 Redis 内在原因，如果不是的话，再定位阻塞发生可能的外在原因。

- **应用层可以加入异常监控逻辑**，比如引入日志系统，统计阻塞的情况。
- 可以借助一些 Redis 监控系统进行阻塞监控。
- 可以通过定期分析 Redis 日志的方式来发现阻塞的问题。
- 使用 Redis 提供的慢查询功能进行慢查询分析，如 slowlog get {n} 获取慢查询记录。但是慢查询只记录命令执行的时间，而阻塞原因是多种多样的。



#### 阻塞内在原因

##### 1. API或数据结构使用不合理

有的命令的时间复杂度是 **O(N)** 的，如果数据量比较大（**大对象**），那么就容易造成阻塞。**应该避免在大对象上执行复杂度超过 O(N) 的命令。**

这类原因适合用**慢查询记录**来进行查找。大对象的查找可以通过 **redis-cli --bigkeys** 命令进行扫描寻找。

解决方法：

① 修改为时间复杂度较低的算法。比如 hegtall 修改为 hmget，禁用 keys、sort 命令等。

② 调整大对象。将大对象数据拆分成多个小对象，防止一次操作读取过多数据。

##### 2. CPU饱和

Redis 执行命令只会用一个 CPU，CPU 饱和是指 Redis 把单核 CPU 使用到了接近 100%。

使用 **top 命令**可以识别出 Redis 进程是否占用了较多 CPU。

##### 3. 持久化阻塞

持久化过程挺多造成阻塞的原因。

###### ① fork阻塞

fork 操作发生在**执行 RDB 或 AOF 的重写**时，主线程调用 fork 产生**子进程**完成持久化操作。

这个过程也可能阻塞。

可以执行 **info stats** 命令获取到 **latest_fork_usec** 指标查看最近一次 fork 操作的耗时。

###### ② AOF刷盘阻塞

开启 AOF 持久化时，文件刷盘方式一般采用每秒 1 次，后台线程每秒对 AOF 文件做 **fsync** 操作。

当主线程发现距离上一次的 fsync 成功**超过 2 秒**时，为了数据安全性它会**阻塞**直到后台线程执行 fsync **成功**。

这种阻塞行为主要是由**硬盘压力**引起的，比如其他进程正在大量占用硬盘资源，导致 Redis 进程刷盘超时。可以使用 **iotop** 指令查看进程使用**硬盘资源**的情况。

###### ③ HugePage写操作阻塞

子进程在执行重写期间利用 Linux 写时复制技术降低内存开销，因此只有在写操作的时候 Redis 才复制要修改的内存页。

对于**开启了 Transparent HugePage** 的操作系统，每次**写命令**引起的复制内存页单位由 4K 变为 2MB，增大了 512倍，会**拖慢写操作**执行时间。



#### 阻塞外在原因

##### 1. CPU竞争

Redis 是典型的 CPU 密集型应用，不建议和其他密集型服务一起部署。其他进程可能竞争 CPU。此外，如果做了 CPU 绑定，那么子进程和父进程会共享使用同一个 CPU，子进程占用 CPU 通常较大，对于开启了持久化或者参与复制的主节点不建议绑定 CPU。

##### 2. 内存交换

Redis 本来就是基于内存工作的，如果**发生了内存交换**那么对性能影响**极大**。排查方式如下。

- 查询 Redis 进程号

```bash
redis-cli -p 6739 info server | grep process_id
process_id:4476
```

- 根据进程号查看内存交换信息

```bash
cat /proc/4476/smaps | grep Swap
```

为防止内存交换，需要保证机器**内存充足**，也确保所有 Redis 实例**设置最大可用内存**。

##### 3. 网络问题

通信通过网络进行，网络也可能出现问题导致阻塞。常见问题有：**连接拒绝、网络延迟、网卡软中断**等。





#### 参考资料

- 《Redis开发与运维》



