# 1. 网络基础
## 1.1 ISP
互联网服务提供商。目前的互联网是一种多层次的ISP，分为第一层ISP，区域ISP和接入ISP，互联网交换点是IXP
## 1.2 主机间通讯方式
- 客户-服务器(C/S)：client-server
- 对等(P2P)
## 1.3 电路交换与分组交换
### 1.3.1 电路交换
用于电话系统，两个用户通信需要一条物理链路，过程中始终占用
### 1.3.2 分组交换
每个分组有首部尾部，包含控制信息，可在同一线路传播
## 1.4 时延
总时延 = 排队时延 + 处理时延 + 传输时延 + 传播时延
## 1.5计算机网络体系结构

# 2. 数据链路层
## 2.1 概述
- 协议数据单元--帧
- 作用：将网络层叫下来的数据报(分组)封装成帧发送到链路上，同时也可以取出接收到的帧中的数据交给网络层
- 数字管道
## 2.2 信道类型
### 2.2.1 点对点信道
**通信流程：**
1. 节点A的数据链路层把网络层交下来的IP数据包添加首尾部封装成帧
2. A把帧发送给B的数据链路层
3. B检测收到的帧有无差错，无则上交，有则丢弃(重发由上层负责)

一对一通信，不会发生碰撞，由PPP协议控制(Ponit to Point Protocol)

**基本问题**
1. 封装成帧
添加首尾部，标记帧的开始和结束
MTU：最大传送单元，即帧的数据部分的长度上限
SOH+数据+EOT
2. 透明传输
如果数据部分有开始结束符一样的数据，则要使用**字节填充**，添加转义字符
3. 差错检测
使用循环冗余检验(CRC)来检查比特差错

**PPP协议**
是用户计算机和ISP通信时使用的数据链路层协议

### 2.2.2 广播信道
一对多通信
控制方法：
1. 信道复用技术
2. CSMA/CD协议
载波监听多点接入、碰撞检测，双向交替通信(半双工通信)

## 2.3 网络适配器(adapter)
又称网络接口板，网络接口卡(网卡)(Network Interface Card)

进行串行/并行转换、数据缓存、数据封装解封、链路管理、安装设备驱动程序、实现以太网协议

## 2.4 MAC地址
固化在局域网中计算器适配器的ROM中的，又叫硬件地址或物理地址，是链路层地址，长度6字节(48位)，唯一标识网络适配器

## 2.5 以太网
以太网是一种星型拓扑结构局域网

早期集线器(物理层设备)，现在交换机(链路层设备)，不会碰撞，根据MAC地址进行存储转发

以太网帧格式：
- 类型：标记上层使用的协议
- 数据：长度在46-1500间，太小则需要填充
- FCS： 帧检验序列，使用的是CRC检验方法

# 3. 网络层
TCP/IP体系中的网络层向上只提供简单灵活的、无连接的、尽最大努力交付的数据报服务

网际层IP协议配套协议：
- 地址解析协议ARP(Address Resolution Protocol)
- 网际控制报文协议ICMP(Internet Control Message Protocol)
- 网际组管理协议IGMP(Internet Group Management Protocol)

## 3.1 虚拟互联网络
逻辑互连网络(IP协议)
将异构的网络连接起来：
- 物理层中继：转发器
- 数据链路层中继：以太网交换机
- 网络层中继：路由器
- 网络层以上中继：网关

## 3.2 IP地址的编址方式
### 3.2.1 基础分类
网络号(net-id)和主机号(host-id): IP共32位，4个字节
IP地址 ::= {<网络号>,<主机号>}  ::= 表示定义为
ABC类地址net-id字段分别为1，2，3个字节
### 3.2.2 子网划分
二级IP地址缺点多：
- IP地址空间的利用率有时很低
- 给每一个物理网络分配网络号会使路由表变大而网络性能变坏
- 两级的IP地址不够灵活

在主机号字段中取一部分作为子网号(subnet-id)，分为三级IP地址
IP地址 ::= {<网络号>,<子网号>,<主机号>}
**子网掩码**
子网掩码的长度也是32位。位=1：IP地址对应位为网络号和子网号；位=0：IP地址对应位为主机号
**IP地址 & 子网掩码 = 网络地址**
A,B,C类默认子网掩码：
A 255.0.0.0
B 255.255.0.0
C 255.255.255.0
### 3.2.3 无分类编址CIDR
用于构建超网
IP地址 ::= {<网络前缀>,<主机号>}

## 3.3 IP地址与硬件地址
硬件地址(MAC地址)是数据链路层和物理层使用的地址，放在MAC帧首部
IP地址是网络层和以上层使用的地址，是逻辑地址，放在IP数据报首部

## 3.4 地址解析协议ARP
从网络层使用的IP地址解析出在数据链路层使用的MAC硬件地址

ARP高速缓存：本局域网内各主机和路由器的IP地址到MAC地址的映射表

## 3.5 IP数据报的格式
首部 + 数据。
首部的前一部分是固定长度，20字节。固定后的部分是可选字段，长度可变。

- 版本：4(IPV4)和6(IPV6)两个值
- 首部长度：4位，最大值为15.值为1表示一个32位字的长度，即4个字节，固定部分长度20字节，则该值最小为5，如果可选长度不是4的倍数，需要填充
- 区分服务：用于获得更好的服务，一般情况下不实用
- 总长度：包括首部长度和数据部分长度。最长65536字节，总长度不能超过数据链路层的最大传输单元MTU长度，超过需要分片处理
- 生存时间：TTL，防止无法交付的数据报在互联网兜圈，每过一个路由器减一，为0则丢弃数据报
- 协议：指出携带的数据应该上交给哪个协议处理，如ICMP,TCP,UDP,IP,IPv6,OSPF等
- 首部检验和：每过一个路由器，重新计算
- 标识：如果发生分片，不同分片需要相同的标识符
- 片偏移：和标识符一样，用于发生分片的情况。单位为8字节，分出的数据片需要复制原来的头部信息但是修改一下片偏移信息
- 源地址：4字节
- 目的地址：4字节
- 可选字段：1-40字节不等，用0填充非4倍数

## 3.6 IP层转发分组的流程
路由表中重要信息：目的网络地址，下一跳地址
特点：可以根据目的网络地址确定下一跳路由器
- 特定主机路由
- 默认路由
**路由分组转发算法**

## 3.7 网际控制报文协议ICMP
### 3.7.1 ICMP种类
1. ICMP差错报告报文
  - 终点不可达
  - 时间超过
  - 参数问题
  - 改变路由(重定向)
2. ICMP询问报文
  - 回送请求和回答报文
  - 时间戳和回答报文
### 3.7.2 ICMP报文格式
前4个字节统一，三个字段：类型、代码和检验和
后四个字节与ICMP类型又换
### 3.7.3 应用
1. Ping     
向目的主机发送ICMP Echo请求报文，目的主机接收后会发送回答报文，以计算往返时间和丢包率
2. Traceroute     
跟踪一个分组从源到终点的路径

## 3.8 路由选择协议
### 3.8.1 概述
即讨论路由表怎么得到

分层次，分为多个小的自治系统AS

分为内部网关协议IGP(Interior Gateway Protocol) 和 外部网关协议 EGP(Extern Gateway Protocol)

### 3.8.2 内部网关协议之RIP
分布式的，基于距离向量的(最多15个)

要求每一路由器都要维护从自己到每一个目的网络的距离记录

特点：好消息传播快，坏消息传播慢

### 3.8.3 内部网关协议之OSPF
开放最短路径优先(Open Shortest Path First)。适用于规模较大的网络，使用分布式的链路状态控制协议。

### 3.8.4 外部网关协议之BGP
边界网关协议(Border Gateway Protocol)。不同自治系统的路由器之间交换信息的协议，采用路径向量路由选择协议

### 3.8.5 路由器
网络层设备，功能上分为：路由选择和分组转发。

分组转发结构分为三个部分：交换结构、一组输入端口、一组输出端口

**路由器和交换机的区别**
1. 都是一根网线上网，但是大家分别拨号，不影响，路由器虚拟拨号，共用一个账号，上网相互影响
2. 交换机工作在中继层，根据MAC寻址，路由器工作在网络层，根据IP寻址，路由器可以处理TCP/IP协议，交换机不可以
3. 交换机可以组成局域网，路由器不行；路由器可以自动识别数据报发送和到达的地址
4. 路由器提供防火墙服务，防止广播风暴

## 3.9 IPv6
### 3.9.1 IPv6格式
仍支持无连接的传送，但将协议数据单元PDU称为**分组**     
数据报由两大部分组成：基本首部和有效载荷，有效载荷允许有0-多个扩展首部，之后是数据部分    
IPv6首部长度固定40字节，为基本首部，首部字段数只有8个：
- 版本：4位。指明了协议的版本，对IPv6是6
- 通信量类：8位。区分不同的类别和优先级
- 流标号：20位，指明同一个流的数据有同样的流标号
- 有效载荷长度：16位。除基本首部外的字节数，最大值64KB
- 下一个首部：8位，相当于IPv4的协议字段或可选字段
- 跳数限制：8位，跳数为0就要丢弃
- 源地址：128位
- 目的地址：128位
### 3.9.2 IPv6的地址
目的地址：
- 单播：点对点
- 多播：一对多，发送给一组计算机的每一个
- 任播：特有的，交给终点计算机组中的任一个，通常是距离最近的

使用冒号16进制记法，允许零压缩，即一连串连续的0用一对冒号取代，在任一地址中只能使用一次。     
特殊地址：
- 未指明地址：16字节的全0地址(::)，不能用作目的地址
- 环回地址：0:0:0:0:0:0:0:1(::1)，对应IPv4的127.0.0.1
- 基于IPv4的地址：前缀为0000 0000保留一小部分地址作为与IPv4兼容的
- 本地链路单播地址：本地地址通信，不能与因特网上其他主机通信
- 全球单播地址：使用最多一类，可分三级，用n比特作为全球路由选择前缀，m比特作为子网前缀。剩下的128-m-n作为接口标识符
### 3.9.3 IPv6的过渡
1. 双栈协议(dual stack)     
在完全过渡到IPv6前，是一部分主机或路由具有两个协议栈，同时具备两种IP地址。根据DNS返回的地址类型来确定使用IPv4地址还是IPv6地址
2. 隧道技术    
在IPv6数据报进出IPv4网络时，进行数据报的封装和还原
### 3.9.4 ICMPv6
IP多播
### 3.10 虚拟专用网VPN
并不需要把机构所有主机接入外部互联网，使用本机构有效的IP地址（专用地址）
三个专用地址块：
10.0.0.0~10.255.255.255
172.16.0.0~172.31.255.255
192.168.0.0~192.168.255.255

路由器对目的地址是专用地址的数据报一律不转发

网络地址转换NAT
专用网使用本地IP地址又想和互联网上主机通信时，可以使用NAT来转换为全球IP


# 4. 传输层
## 4.1 概述
### 4.1.1 进程间通信
向应用层提供通信服务，属于面向通信部分的最高层，也是用户功能的最底层
### 4.1.2 传输层的两个协议
- 用户数据报协议UDP(User Datagram Protocol)：无连接，使用不可靠信道，尽最大可能交付，没有拥塞机制，对应用程序传下来的报文不拆分和合并，只添加UDP首部，交互通信
- 传输控制协议TCP(Transmission Control Protocol):面向连接，提供可靠交付，有流量控制，全双工通信，面向字节流，只能点对点
应用|应用层协议|传输层协议
:--:|:--:|:--:
名字转换|DNS(域名系统)|UDP
文件传输|TFTP(简单文件传送协议)|UDP
路由选择协议|RIP(路由信息协议)|UDP
IP地址配置|DHCP(动态主机配置协议)|UDP
网络管理|SNMP(简单网络管理协议)|UDP
远程文件服务器|NFS(网络文件系统)|UDP
IP电话|专用协议|UDP
流式多媒体传播|专用协议|UDP
多播|IGMP(网际组管理协议)|UDP
电子邮件|SMTP(简单邮件传送协议)|TCP
远程终端接入|TELNET(远程终端协议)|TCP
万维网|HTTP(超文本传输协议)|TCP
文件传输|FTP(文件传送协议)|TCP

### 4.1.3 传输层的端口
端口用16位端口号标志，允许65535个，端口号只是为了表示计算机应用层的各进程。两个计算机通信需要知道IP地址和端口。

熟知端口0-1023：
登记端口：1024-49151
短暂端口：49152-65535

## 4.2 用户数据报协议UDP
### 4.2.1 概述
无连接，在IP层上增加：复用、分用、差错检测     
无连接则不需要使用套接字
### 4.2.2 UDP协议的首部格式
数据字段和首部字段。      
首部字段8个字节，分为4个字段，各2字节：
- 源端口：需要对方回信使用，不需要则全为0
- 目的端口
- 长度：UDP数据报的长度，最小值为仅有首部的8
- 校验和：把首部和数据部分一起校验
### 4.2.3 UDP特点
1. 无连接的，减小开销和发送数据的时延
2. 尽最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的连接状态
3. 面向报文的，一次性交付一个完整的报文
4. 没有拥塞机制
5. 支持一对一、一对多、多对多的通信
6. 首部开销小，只有8个字节，TCP20个

## 4.3 传输控制协议TCP
### 4.3.1 概述
TCP连接是一条虚连接，而不是真正的物理连接，根据对方给出的窗口值和当前网络拥塞的程度来决定一个报文段包含的字节数。而UDP是应用进程给出的。

**TCP的连接**:一个TCP连接两个端点，叫做套接字或者插口，由端口拼接到IP地址构成     
```
套接字 socket = (IP地址：端口号)
```
一个TCP连接由**两个端点**确定。
```
TCP连接 ::= {socket1,socket2}={(IP1:port1),(IP2:port2)}
```
TCP为了实现可靠传输：
停止等待协议、连续ARQ协议、滑动窗口协议(精髓)

### 4.3.2 TCP报文的首部
面向字节流，但是传送的数据单元是报文段

TCP首部前20字节固定，后续4N字节可选
- 源端口和目的端口：各2字节
- 序号seq：4字节。报文中每一个字节都编上一个序号
- 确认号ack：4字节。是期望收到对方的下一个报文段的数据的第一个字节的序号
若确认号=N，则表示到N-1为止的数据已正确收到
- 数据偏移：4位。即首部长度
- 保留：占6位，今后用，目前置0
- 紧急URG：=1时紧急指针字段有效，应尽快传送
- 确认ACK标志位：=1有效
- 推送PSH：=1时尽快交付，不再等到整个缓存填满后再交付
- 复位RST：=1时表示出现严重差错，必须释放连接再重新建立
- 同步SYN标志位：=1表示是连接请求或连接接收报文，在连接时用来同步序号
- 终止FIN标志位：=1表示要释放连接
- 窗口：占2字节，用来让对方设置发送窗口的依据，动态变化
- 校验和：占2字节，计算校验和时临时在TCP报文段前面加12字节的伪首部。
- 紧急指针字段：16位，指出紧急数据有多少个字节
- 选项：长度可变。最大报文段长度MSS(报文段长度减去首部长度)
- 填充：首部长度为4的倍数

## 4.4 TCP可靠传输的工作原理
### 4.4.1 ARQ协议(Automatic Repeat-reQuest) 自动重传请求
#### 1.停止等待ARQ协议(信道利用率低)
- 停止等待。发送方每次只发送一个分组，收到确认后再发送下一个分组
- 编号。对发送的每个分组和确认都进行编号
- 自动重传请求。为每个分组设置超时计时器，超时则自动重传
- 简单。但信道利用率低

##### ①无差错情况
发送方发送分组，接收方在规定时间内收到，回复确认，发送方再次开始发送
##### ②出现差错
接收方B会出现两种情况：
- B接收M1检测时出错，就丢弃M1，不做其他(不通知A收到差错的分组)
- M1传输过程丢失，B什么都不知道

``那么A如何知道B是否正确收到？``    
**超时重传**
- A为每个分组设置超时计时器
- A在超时前收到确认，撤销计时，发送下一个分组
- 超时前没收到，则重发该分组

``若B正确收到，但返回的响应丢失，A会超时重发，B收到重复的M1，怎么办？``
**编号**
- A对每一个分组编号
- B对每一个分组对应的确认编号
##### ③确认丢失
B返回的确认丢失，收到了A重传的M1：
- 丢弃重复分组，不向上层交付
- 仍要向A发送确认，因为A之所以重传正是因为没有收到确认
##### ④确认迟到
A收到的B的响应确认迟到，则B会收到重复M1，并重传确认分组，A会受到重复确认
##### ⑤信道利用率

### 4.4.2 自动请求重传
在不可靠的传输网络上实现可靠的通信

### 4.4.3 流水线传输
发送方连续发送多个分组，继而演变出连续ARQ协议

### 4.4.4 连续ARQ协议
自动重传请求+流水线
- 发送方一次发送多个分组
- 使用滑动串口协议控制发送方和接收方所能发送和接受的分组的数量和编号
- 每接收到一个确认，发送方就把发送窗口向前滑动
- 接收方采取累积确认的方式，不再对分组逐个确认，可以对按序到达的最后一个分组进行确认表示到这个分组为止的所有分组都已经正确收到了
- 采取回退N的方法进行重传。如果发送方发送量前5个分组，而中间的第三个分组丢失了。这时接收方只能对前两个分组发出确认，发送方需要退回重传已发送的N个分组。

## 4.5 TCP可靠传输的实现
### 4.5.1 滑动窗口协议
发送方和接收方各自维持一个滑动窗口，以字节为单位
注意点：
- A的发送窗口并不总是和B的接收窗口一样大(因为有一定的时间滞后)
- TCP标准没有规定不按序到达的数据如何处理，通常临时放在接收窗口中，等到字节流缺少的字节收到后，再按序交付上层的应用进程
- TCP要求接收方必须有累积确认的功能，减小传输开销
- 真正的发送窗口值的大小还取决于网络的拥塞情况

#### 滑动窗口与缓存
发送缓存用来暂时存放：
- 发送应用程序传送给发送方TCP准备发送的数据
- TCP已发送但未收到确认的数据

接收缓存用来暂时存放：
- 按序到达的，但未被接收应用程序读取的数据
- 不按序到达的数据

### 4.5.2 超时重传时间RTO(Retransmission Time-Out)
>如何设置超时重传时间？    

使用一种自适应算法，记录一个报文段发出的时间和收到相应的确认的时间，这两个时间差是报文段的往返时间RTT，计算加权平均往返时间RTTs，RTO应略大于它。
>如何准确计算RTTs？

报文重传了，则不纳入时间计算的样本

### 4.5.3 选择确认SACK
> 如收到的报文段无差错，只是未按序号，中间还缺少了一些序号的数据，能否设法只传送缺少的数据？

选择确认SACK(Selective ACK)

## 4.6 TCP流量控制
### 4.6.1 概述
流量控制就是控制发送方发送速率，确保接收方来得及接收

接收方发送的确认报文中的窗口字段来控制发送方窗口大小(利用滑动窗口实现流量控制)，窗口为0则不能发送

### 4.6.2 可能发生死锁
B向A发送零窗口报文段后，有了新的空间，如果发送新的窗口值的报文段丢失，则会一直死锁下去，为了解决，为每一个连接设置一个持续时间计时器

### 4.6.3 持续计时器
只要TCP连接的一方收到对方的零窗口通知，就启动该持续计时器

若持续计时器设置的时间到期，就发送一个零窗口探测报文段，而对方就在确认时给出当前的窗口值。

## 4.7 TCP拥塞机制
### 4.7.1 概述
某段时间内，若对网络中某资源的需求超过了该资源所能提供的可用部分，网络的性能就会变坏，称为拥塞。

### 4.7.2 TCP的拥塞控制方法
拥塞控制：基于拥塞窗口变量+几种拥塞控制算法实现
- TCP采用基于拥塞窗口的方法控制，属于闭环控制
- TCP发送方维护一个拥塞窗口cwnd(Congestion Window)的变量，发送端利用拥塞窗口根据网络的拥塞情况调整发送的数据量
- 发送窗口的上限取决于接收方窗口值和拥塞窗口值的最小值

### 4.7.3 TCP拥塞控制算法
- 慢开始(slow-start)
- 拥塞避免(congestion avoidance)
- 快重传(fast retansmit)
- 快恢复(fast recovery)

#### ①慢开始算法
目的：确定网络的负载能力或拥塞程度

算法的思路：由小到大逐渐增大拥塞窗口数值

两个变量：
- 拥塞窗口(cwnd)：初始拥塞窗口值。2-4个最大报文段，窗口值逐渐增大
- 慢开始门限(ssthresh):防止拥塞窗口增长过大引起网络阻塞

每经过一个传输轮次，拥塞窗口就加倍
“传输轮次”是指把拥塞窗口所允许的发送的报文段都连续发送出去，并收到对已发送的最后一个字节的确认。

- 当拥塞窗口<慢开始门限时，使用慢开始算法；
- 当拥塞窗口>慢开始门限时，改用拥塞避免算法
- = 时，两者都可以用

#### ②拥塞避免算法
思路：让拥塞窗口缓慢增大(线性)，避免出现拥塞

超时之前，每经过一个传输轮次，拥塞窗口+1

当网络出现拥塞时(重传定时器超时)：
1. ssthresh = max(cwnd/2, 2)：降低门限值，取一半
2. cwnd = 1
3. 重新执行慢开始算法

目的：迅速减小主机发送到网络中的分组数，使得发生拥塞的路由器有足够的时间把队列中积压的分组处理完毕

#### ③快重传算法
- 发送方只要一连收到三个**重复确认**，就知道接收方确实没有接收到报文段，应当立即重传(快重传)，这样就不会超时，发送方也不会误认为出现网络拥塞
- 可提高网络吞吐量约20%
- 并非取消重传计时器，而是更早的重传
- 让发送方尽早知道发生了个别报文段的丢失
- 要求接收方不要等待自己发送数据时附带确认，而是立即发送确认，即使受到了失序的报文段也要立即发出对已收到的报文段的重复确认

#### ④快恢复算法
发送端收到连续三个重复的确认时，由于发送方现在认为网络很可能没有发生拥塞，因此现在不需要执行慢开始算法，而是执行快恢复算法算法：
1. 慢开始门限ssthresh = 当前拥塞窗口cwnd/2
2. 新拥塞窗口cwnd = 慢开始门限ssthresh
3. 开始执行拥塞避免算法，新的拥塞窗口线性增大

### 4.7.4 AIMD
- 拥塞避免算法中，拥塞窗口是按照线性规律增大的。这常称为“加法增大” AI(Additive Increase)。
- 当出现超时或 3 个**重复的确认**时，就要把**门限值**设置为当前拥塞窗口值的**一半**，并大大减小拥塞窗口的数值这常称为“**乘法减小**”MD (Multiplicative Decrease)。
- 二者合在一起就是所谓的 **AIMD** 算法。

## 4.8 TCP建立连接
TCP是面向连接的协议，传输数据分为三个阶段：
- 连接建立
- 数据传送
- 连接释放

### 4.8.1 连接过程
- 建立连接的过程叫做握手
- 握手要在客户端和服务器之间交换三个TCP报文段，称之为三报文握手

#### 三次握手
1. 服务器首先创建传输控制块TCB，准备接收客户进程的连接请求
2. 客户端发起请求SYN=1，seq=x(SYN是同步号，seq是数据的第一个字节序号)
3. 服务器收到连接请求，SYN=1，标志位ACK=1,确认号ack=x+1,seq=y
4. 客户端发起第三次握手，ACK=1，seq=x+1,ack=y+1完成三次握手，进行数据传输

#### 三次握手的原因？
1. 最主要的目的就是双方确认自己与对方的发送和接收是正常的。
  - 第一次握手：Client什么都不能确认；Server确认了对方发送正常，自己接收正常；
  - 第二次握手：Client确认了：自己发送、接收正常，对方发送、接收正常；Server确认了对方发送正常，自己接收正常；
  - 第三次握手：Client确认了：自己发送、接收正常，对方发送、接收正常；Server确认了对方发送、接收正常，自己发送、接收正常；
2. 进行三次握手为了防止失效的连接请求到达服务器，让服务器打开错误连接，占用服务器资源         
客户端发送的连接请求如果在网络中滞留，会隔很长一段才能收到服务器端发回的连接确认。客户端等待过了超时重传后，就会重新请求连接，但滞留的请求最终还是会到达服务器，如果不进行三次握手，服务器会打开两个连接，如果有三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认(因为序号这些对应不上)。

#### 为什么要传回SYN(握手信号)？
接收端传回发送端所发送的SYN是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。

## 4.9 TCP释放连接
- 数据传输结束后，通信的双方都可以释放连接
- TCP连接释放过程是四报文握手
### 4.9.1 释放过程
假设客户端主动释放连接：
- 数据传输结束后，通信的双方都可以释放连接
- 客户端A的应用进程先向其TCP发出连接释放报文段，并停止再发送数据，主动关闭TCP连接
- A把连接释放报文段首部的FIN=1，其序号seq=u，等待B的确认

服务器收到释放连接的请求，直接回复ACK=1，表示确认收到释放请求，同时回复确认号ack=u+1
- 若服务器B已经没有要向A发送的数据，应用进程就通知TCP释放连接
- 如果B还有未发完的数据，可以继续发送给客户端，直到数据发送完成(此时只能服务端给客户端发送数据，也就是主动发起释放连接的一方只能接受不能发送)

之后服务器再发送一个释放消息，即FIN=1，同时ACK=1，表示收到客户端消息，此时ack=u+1，同时发送自己的序列号seq=w

客户端收到服务器的释放报文后，再次确认，向服务器发送ACK=1，seq=u+1，ack=w+1。四次挥手完成。

同时客户端进行Time-Wait状态，等待2MSL的时间，再关闭。

#### 四次挥手的原因
客户端发送了FIN连接释放报文之后，服务器收到了这个报文，就进入COLSE-WAIT状态，这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕后，会发送FIN连接释放报文。

#### 4.9.2 Time_Wait
接收到FIN报文之后，进入这个状态，而不是直接进入CLOSED状态，还需要等待时间计时器设置的时间2MSL
- 确保最后一个请求报文能够到达。如果B没收到A发来的确认报文，就会重新发送连接释放请求报文，A等待一段时间就是为了处理这种情况
- 等待一段时间是为了让本连接相关的所有报文都从网络中消失，使得下一个连接不会出现旧的连接的请求报文

#### 4.9.3 其他
##### ①保活计时器
用来防止TCP连接出现长时期的空闲，比如客户端直接断电，来不及发送释放的报文

通常设置为2小时，如果服务器过了2小时还未收到客户的消息，就发出探测报文段，若发出10个探测报文段(每个相隔75秒)还没响应，就假定客户端故障，终止连接。

##### ②TCP有限状态机
连接状态：
- CLOSED：初始状态
- LISTEN：服务器处于监听状态
- SYN_SEND：客户端socket执行CONNECT连接，发送SYN包，进入此状态
- SYN_RECV：服务端收到SYN包并发送SYN包，进入此状态
- ESTABLISH：表示连接建立。客户端发送最后一个ACK包后进入此状态，服务端接收到ACK包后进入此状态
- FIN_WAIT_1：终止连接的一方(通常是客户端)发送FIN报文后进入此状态，等待对方FIN
- CLOSE_WAIT：(假设服务器)接收到客户机FIN包之后等待关闭的阶段，在接收到对方的FIN包之后，需要立即回复ACK包，表示已经知道断开请求，但是本方是否立即断开连接(发送FIN包)取决于是否还有数据需发送，若有，则在发送完成后发送FIN包前都处于此状态
- FIN_WAIT_2：此前是半连接状态，即有一方要求关闭连接，等待另一方关闭。客户端收到服务器的ACK包，但并没有立即收到服务端的FIN包，进入FIN_WAIT_2状态
- LAST_ACK：服务端发送最后的FIN包，等待最后的客户端ACK响应，进入此状态
- TIME_WAIT：客户端收到服务端的FIN包，并立即发出ACK包做最后的确认，此后的2MSL时间称为TIME_WAIT状态

#### 4.10 TCP保证可靠传输
1. 应用数据被分割为TCP认为最适合发送的数据块
2. TCP对每一个发送的包进行编号，接收方对数据包排序，将有序数据传送给应用层
3. 校验和：TCP保持它首部和数据的校验和。这是端到端的校验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP将丢弃这个报文段和不确认收到
4. TCP接收端会丢弃重复的数据
5. 流量控制：TCP连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。流量控制是可变大小的滑动窗口协议
6. 拥塞机制：网络拥塞时，减少数据的发送
7. ARQ协议：每发完一个分组就停止发送，等待对方确认。确认后再发送下一个分组
8. 超时重传：当TCP发出一个段后，启动一个定时器，等待目的端确认收到这个报文段，如果不能及时收到确认，重发。

# 5. 应用层
**应用层常用端口表**

|       应用       | 应用层协议 |  端口号   | 传输层协议 |             备注             |
| :--------------: | :--------: | :-------: | :--------: | :--------------------------: |
|   **域名解析**   |  **DNS**   |  **53**   |  UDP/TCP   | 长度超过 512 字节时使用 TCP  |
| 动态主机配置协议 |  **DHCP**  |   67/68   |    UDP     |                              |
| 简单网络管理协议 |    SNMP    |  161/162  |    UDP     |                              |
|   文件传送协议   |  **FTP**   | **20/21** |    TCP     | **控制连接 21，数据连接 20** |
|   远程终端协议   |   TELNET   |  **23**   |    TCP     |                              |
|  超文本传送协议  |  **HTTP**  |  **80**   |    TCP     |                              |
| 简单邮件传送协议 |    SMTP    |    25     |    TCP     |                              |
|   邮件读取协议   |    POP3    |    110    |    TCP     |                              |
| 网际报文存取协议 |    IMAP    |    143    |    TCP     |                              |
## 5.1 域名系统DNS
### 5.1.1 概述
互联网采用层次结构的命名树作为主机的名字，并使用分布式的域名系统DNS(Domain Name System)
### 5.1.2 域名结构
```
... .三级域名.二级域名.顶级域名
```

#### 顶级域名TLD(Top Level Domain)
国家顶级域名 nTLD(.cn,.us)
### 5.1.3 域名服务器
- 一个服务器所负责管辖的（或有权限的）范围叫做**区 (zone)**。
- 各单位根据具体情况来划分自己管辖范围的区。但在一个区中的所有节点必须是能够连通的。
- 每一个区设置相应的**权限域名服务器**，用来保存该区中的所有主机的域名到 IP 地址的映射。
- DNS 服务器的管辖范围不是以“域”为单位，而**是以“区”为单位**。

- 权限域名服务器      
- 本地域名服务器
### 5.1.4 域名解析过程
- **主机向本地域名服务器的查询一般都是采用递归查询**。如果主机所询问的本地域名服务器不知道被查询域名的 IP 地址，那么本地域名服务器就以 DNS 客户的身份，向其他根域名服务器继续发出查询请求报文。
- **本地域名服务器向根域名服务器的查询通常是采用迭代查询**。当根域名服务器收到本地域名服务器的迭代查询请求报文时，要么给出所要查询的 IP 地址，要么告诉本地域名服务器：“你下一步应当向哪一个域名服务器进行查询”。然后让本地域名服务器进行后续的查询。

每个域名服务器都维护一个**高速缓存**，存放最近用过的名字以及从何处获得**名字映射信息**的记录。可大大减轻根域名服务器的负荷，使互联网上的 DNS 查询请求和回答报文的数量大为减少。 缓存应该设置合理的过期时间。

#### DNS 用什么协议传输？
DNS 可以使用 **UDP 或者 TCP** 进行传输，使用的端口号都为 **53**。**大多数情况下 DNS 使用 UDP进行传输**。为什么？
- UDP 速度**更快**。TCP 很慢，因为它需要 3 次握手。DNS 服务器上的**负载**也是一个重要因素。DNS 服务器（因为它们使用 UDP）没有保持连接。
- DNS 请求通常非常小，非常适合 UDP 段。
- UDP 不可靠，但可以在**应用层添加可靠性**。应用程序可以使用 UDP，并且可以通过在**应用程序层使用超时和重新发送**来实现可靠性。

在两种情况下会使用 **TCP** 进行传输：
- 如果返回的响应超过的 **512 字节**（UDP 最大只支持 512 字节的数据）。
- 区域传送（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。

## 5.2文件传送协议FTP
### 5.2.1 FTP特点
- 文件传送协议 FTP 只提供文件传送的一些**基本**的服务，它使用 **TCP** 可靠的运输服务。
- 主要功能是减少或消除在不同操作系统下处理文件的**不兼容**性。
- 使用客户服务器方式。一个 FTP 服务器进程可同时为多个客户进程提供服务。FTP 的服务器进程由两大部分组成：一个**主进程**，负责接受新的请求；另外有**若干个从属进程**，负责处理单个请求。
### 5.2.2 主进程工作步骤
- 打开熟知端口（端口号为 **21**），使客户进程能够连接上。
- 等待客户进程发出连接请求。
- 启动**从属进程**来处理客户进程发来的请求。从属进程对客户进程的请求处理完毕后即终止，但从属进程在运行期间根据需要还可能创建其他一些子进程。
- 回到**等待**状态，继续接受其他客户进程发来的请求。主进程与从属进程的处理是并发地进行。
### 5.2.3 两个TCP连接
- 控制连接在整个会话期间一直保持打开，FTP 客户发出的传送请求通过控制连接发送给服务器端的控制进程，但控制连接**不用**来传送文件。当客户进程向服务器进程发出建立**连接请求**时，要寻找连接服务器进程的熟知端口 (21)，同时还要告诉服务器进程自己的另一个端口号码，用于建立数据传送连接。
- 数据传送进程实际完成文件的传送，在传送完毕后关闭“数据传送连接”并结束运行。
### 5.2.4 两种模式
根据数据连接是否是**服务器端主动建立**，FTP 有主动和被动两种模式：
- 主动模式：服务器端主动建立数据连接，其中服务器端的端口号为 **20**，客户端的端口号随机，但是必须大于 1024，因为 0\~1023 是熟知端口号。
- 被动模式：客户端主动建立数据连接，其中客户端的端口号由客户端自己指定，服务器端的端口号随机。

**主动模式**要求客户端**开放端口号**给服务器端，需要去配置客户端的防火墙。被动模式只需要服务器端开放端口号即可，无需客户端配置防火墙。但是**被动模式**会导致服务器端的**安全性减弱**，因为开放了过多的端口号。
## 5.3 TFTP
- TFTP (Trivial File Transfer Protocol) 是一个很小且易于实现的文件传送协议，其端口号码为69。
- TFTP 使用客户服务器方式和使用 UDP 数据报，因此 TFTP 需要有自己的差错改正措施。
- TFTP 只支持文件传输而不支持交互。
- 没有一个庞大的命令集，没有列目录的功能，也不能对用户进行身份鉴别。
- TFTP 很像停止等待协议。
## 5.4 动态主机配置协议DHCP
在协议软件中，给协议参数赋值的动作叫做协议配置。一个协议软件在使用之前必须是已正确配置的。
连接到互联网的计算机的协议软件需要配置的参数包括：
1. IP 地址
2. 子网掩码
3. 默认路由器的 IP 地址
4. 域名服务器的 IP 地址

- 这些信息通常存储在一个**配置文件**中，计算机在引导过程中可以对这个文件进行存取。

**DHCP** (Dynamic Host Configuration Protocol) 提供了**即插即用的连网方式**，用户不再需要手动配置 IP 地址等信息。这种机制允许一台计算机加入新的网络和获取 IP 地址，而不用手工配置。

### 5.4.1 DHCP工作过程
- 需要 IP 地址的主机在启动时就向 DHCP 服务器**广播**发送**发现报文**(DHCPDISCOVER)，这时主机就成为DHCP客户
- 本地网络上**所有主机**都能收到此广播报文，但只有**DHCP 服务器才回答**此广播报文。
- DHCP 服务器先在其数据库中查找该计算机的**配置信息**。若找到，则返回找到的信息。若找不到，则从服务器的 IP 地址池 (address pool) 中取一个地址分配给该计算机。DHCP服务器的回答报文叫做**提供报文**（DHCPOFFER），DHCP 服务器返回信息是以**单播方式**进行
- DHCP 基于**UDP**工作，DHCP**服务器**运行在 67 号端口， DHCP**客户**运行在 68 号端口。

#### 具体流程
1. DHCP 服务器被动打开UDP端口67，等待客户端发来的报文。
2. 客户端发送**Discover**报文，该报文的目的地址为**255.255.255.255:67**，源地址为**0.0.0.0 : 68**，被放入UDP中，该报文被广播到同一个子网的所有**主机**上。如果客户端和**DHCP 服务器**不在同一个子网，就需要使用中继代理。
3. DHCP 服务器收到Discover报文之后，发送**Offer报文**给客户端，该报文包含了客户端所需要的信息。因为客户端可能收到**多个DHCP服务器**提供的信息，因此客户端需要进行**选择**。
4. 如果客户端选择了某个DHCP服务器提供的信息，那么就发送**Request 报文**给该DHCP服务器。
5. 被选择的DHCP服务器发送确认报文DHCPACK，进入已绑定状态，并可**开始使用**得到的临时IP地址了。DHCP客户现在要根据服务器提供的租用期T设置两个计时器T1和T2，它们的超时时间分别是0.5T 和0.875T。当超时时间到就要请求更新租用期。
6. 租用期过了一半（T1 时间到），DHCP 发送请求报文DHCPREQUEST，要求更新租用期。
7. DHCP 服务器若同意，则发回确认报文DHCPACK。DHCP客户得到了新的租用期，重新设置计时器。
8. DHCP 服务器若不同意，则发回否认报DHCPNACK。这时DHCP客户必须立即停止使用原来的IP地址，而必须重新申请IP地址（回到步骤2）。若DHCP服务器不响应步骤6的请求报文 DHCPREQUEST，则在租用期过了 87.5% 时，DHCP 客户必须重新发送请求报文 DHCPREQUEST（重复步骤  6），然后又继续后面的步骤。
9. DHCP客户可随时提前终止服务器所提供的租用期，这时只需向DHCP服务器发送释放报文 DHCPRELEASE即可。

### 5.5 TELNET远程登录协议
**TELNET** 用于登录到远程主机上，并且远程主机上的输出也会返回。可以适应许多计算机和操作系统的差异，例如不同操作系统系统的换行符定义。    

## 5.6 电子邮件协议
一个电子邮件系统由三部分组成：用户代理、邮件服务器以及邮件协议。

邮件协议包含发送协议和读取协议，发送协议常用 **SMTP**，读取协议常用 **POP3 和 IMAP**。

### 5.6.1 SMTP
SMTP 只能发送 **ASCII 码**，而互联网邮件扩充MIME可以发送二进制文件。MIME 并没有改动或者取代 SMTP，而是增加邮件主体的结构，定义了非 ASCII 码的编码规则。

### 5.6.2 POP3
POP3 的特点是只要用户从服务器上读取了邮件，就把该邮件删除。

### 5.6.3 IMAP
IMAP 协议中客户端和服务器上的邮件保持同步，如果不手动删除邮件，那么服务器上的邮件也不会被删除。IMAP 这种做法可以让用户随时随地去访问服务器上的邮件。

## 5.7 应用进程跨越网络的通信
### 5.7.1 系统调用和应用编程接口
大多数操作系统使用**系统调用** (system call ) 的机制在应用程序和操作系统之间传递控制权。

对程序员来说，每一个系统调用和一般程序设计中的函数调用非常相似，只是系统调用是将控制权传递给了**操作系统**。系统调用接口实际上就是应用进程的控制权和操作系统的控制权进行转换的一个接口。

使用系统调用之前要编写一些程序，特别是需要设置系统调用中的许多参数，因此这种系统调用接口又称为应用编程接口 API (Application Programming Interface) 。

### 5.7.2 套接字
- 当应用进程需要使用网络进行通信时就发出**系统调用**，请求操作系统为其创建“**套接字**”，以便把网络通信所需要的系统资源分配给该应用进程。
- 操作系统为这些资源的总和用一个叫做**套接字描述符**的号码来表示。
- 应用进程所进行的网络操作都必须使用这个套接字描述符。
- 通信完毕后，应用进程通过一个关闭套接字的系统调用通知操作系统回收与该套接字描述符相关的所有资源。

### 5.7.3 几种常用的系统调用
当应用进程需要使用网络进行通信时，就发出系统调用。使用 TCP/IP 应用编程接口 API，就可以编写基于互联网的网络应用程序了。调用 API 时，用户可以使用 TCP 服务，也可以使用 UDP 等其他服务。系统调用使用顺序的例子（里面包含一些常用的系统调用）

# 6. 网络安全
## 6.1 网络安全问题概述
### 6.1.1 网络攻击
1. 被动攻击
  - 指攻击者从网络上**窃听**他人的通信内容。
  - 通常把这类攻击称为**截获**。
  - 在被动攻击中，攻击者只是观察和分析某一个协议数据单元 PDU，以便了解所交换的数据的某种性质。但不干扰信息流。
  - 这种被动攻击又称为流量分析 (traffic analysis)。
2. 主动攻击
  - **篡改**——故意篡改网络上传送的报文。这种攻击方式有时也称为更改报文流。
  - **恶意程序**——种类繁多，对网络安全威胁较大的主要包括：计算机病毒、计算机蠕虫、特洛伊木马、逻辑炸弹、后门入侵、流氓软件等。
  - **拒绝服务** **DoS**——指攻击者向互联网上的某个服务器不停地发送大量分组，使该服务器无法提供正常服务，甚至完全瘫痪。若从互联网上的成百上千的网站集中攻击一个网站，则称为分布式拒绝服务 DDoS。
3. 对策
  - 对于主动攻击，可以采取适当措施加以检测。
  - 对于被动攻击，通常却是检测不出来的。
  - 根据这些特点，可得出计算机网络通信安全的目标：
    1. 防止分析出报文内容和流量分析。
    2. 防止恶意程序。
    3. 检测更改报文流和拒绝服务。
  - 对付被动攻击可采用各种数据加密技术。
  - 对付主动攻击则需将加密技术与适当的鉴别技术相结合
### 6.1.2 数据加密模型
- 加密和解密用的**密钥K** (key) 是一串秘密的字符串（即比特串）。
- 明文通过加密算法 E  和加密密钥 K  变成密文。
- 接收端利用解密算法 D 运算和解密密钥 K  解出明文 X。解密算法是加密算法的**逆运算**。
- 加密密钥和解密密钥可以一样，也可以**不一样**。
- 密钥通常由密钥中心提供。
- 当密钥需要向远地传送时，一定要通过另一个安全信道。

## 6.2 两类密码体制
### 6.2.1 对称密钥密码体制
#### ①概述
所谓常规密钥密码体制，即**加密密钥与解密密钥是相同的密码体制**。这种加密系统又称为**对称密钥**系统。

数据加密标准 DES 属于**对称密钥密码体制**，是一种**分组密码**。在加密前，先对整个明文进行分组。每一个组长为 64 位。然后对每一个 64 位 二进制数据进行加密处理，产生一组 64 位密文数据。最后将各组密文串接起来，即得出整个的密文。使用的密钥为 64 位（**实际密钥长度为 56 位**，有 8 位用于奇偶校验)。

DES 的**保密性仅取决于对密钥的保密**，其**算法是公开**的。目前较为严重的问题是 DES 的密钥的长度。现在已经设计出搜索 DES 密钥的专用芯片。56 位 DES 已不再认为是安全的了。

#### ②三重DES
- 使用两个 56 位的密钥。
- 把一个 64 位明文用一个密钥加密，再用另一个密钥解密，然后再使用第一个密钥加密。

### 6.2.2 公钥密码体制
#### ①概述
公钥密码体制（又称为公开密钥密码体制）使用**不同的加密密钥与解密密钥**，是一种“由已知加密密钥推导出解密密钥在计算上是不可行的”密码体制。

公钥密码体制产生的主要原因：
- 常规密钥密码体制的密钥分配问题。
- 对**数字签名**的需求。

**加密密钥 PK**（public key，即公钥）是向公众**公开**的，而**解密密钥 SK**（secret key，即私钥或秘钥）则是需要**保密**的。加密算法 E 和解密算法 D 也都是**公开**的。虽然私钥 SK 是由公钥 PK 决定的，但却**不能**根据 PK 计算出 SK。

#### ②公钥算法
- 密钥对**产生器**产生出接收者 B 的一对密钥：**加密密钥 PKB 和解密密钥 SKB** 。
- 加密密钥 PKB 就是接收者 B 的**公钥**，它向公众**公开**。
- 解密密钥 SKB 就是接收者 B 的**私钥**，对其他人都**保密**。
- 发送者 A 用 B 的公钥 PKB 对明文 X 加密（E 运算）后，接收者 B 用自己的私钥 SKB 解密（D 运算），即可恢复出明文。

#### ③公开密钥与对称密钥的区别
- 在使用**对称密钥**时，由于双方使用同样的密钥，因此在通信信道上可以进行**一对一的双向保密通信**，每一方既可用此密钥加密明文，并发送给对方，也可接收密文，用同一密钥对密文解密。这种保密通信仅限于持有此密钥的双方（如再有第三方就不保密了）。
- 在使用**公开密钥**时，在通信信道上可以是**多对一的单向保密通信**。

## 6.3 数字签名
### 6.3.1 概述
用于证明**真实性**。

数字签名必须保证以下三点：
- 报文鉴别——接收者能够核实发送者对报文的签名（**证明来源**）；
- 报文的完整性——发送者事后不能抵赖对报文的签名（**防否认**）；
- 不可否认——接收者不能伪造对报文的签名（**防伪造**）。

采用公钥算法更容易实现
### 6.3.2 基于公钥的数字签名的实现
- 因为除 A 外没有别人能具有 A 的私钥，所以除 A 外没有别人能产生这个密文。因此 B 相信报文 X 是 A 签名发送的。
- 若 A 要抵赖曾发送报文给 B，B 可将明文和对应的密文出示给第三者。第三者很容易用 A 的公钥去证实 A 确实发送 X 给 B。
- 反之，若 B 将 X 伪造成 X'，则 B 不能在第三者前出示对应的密文。这样就证明了 B 伪造了报文。
### 6.3.3 具有保密性的数字签名

## 6.4 鉴别
在信息的安全领域中，对付**被动攻击**的重要措施是**加密**，而对付**主动攻击**中的**篡改和伪造**则要用**鉴别** (authentication)。      
报文鉴别使得通信的接收方能够验证所收到的报文（发送者和报文内容、发送时间、序列等）的**真伪**。        
使用**加密**就可达到**报文鉴别**的目的。但在网络的应用中，许多报文**并不需要**加密。应当使接收者能用很**简单的方法**鉴别报文的真伪。
**鉴别分类**
- **报文鉴别**：鉴别所收到的报文的确是报文的**发送者**所发送的，而不是其他人伪造的或篡改的。这就包含了**端点鉴别和报文完整性**的鉴别。
- **实体鉴别**：仅仅鉴别发送报文的**实体**。实体可以是一个人，也可以是一个进程（客户或服务器）。这就是**端点鉴别**。
### 6.4.1 报文鉴别
许多报文**并不需要加密**，但却需要**数字签名**，以便让报文的**接收者**能够鉴别报文的**真伪**。然而对很长的报文进行数字签名会使计算机增加很大的**负担**（需要进行很长时间的运算）。当我们传送不需要加密的报文时，应当使接收者能用**很简单**的方法鉴别报文的真伪。
#### ①密码散列函数
**数字签名**就能够实现对报文的**鉴别**。**缺点**：对较长的报文（这是很常见的）进行数字签名会使计算机增加非常大的负担，因为这需要**较多的时间**来进行运算。      
**密码散列函数** (cryptographic hash function)是一种**相对简单**的对**报文进行鉴别**的方法。
- 散列函数的输入长度可以很长，但其**输出长度则是固定**的，并且较短。散列函数的输出叫做**散列值**，或称为散列。
- 不同的散列值肯定对应于不同的输入，但不同的输入却可能得出相同的散列值。这就是说，散列函数的输入和输出并非一一对应，而是**多对一**的。在密码学中使用的散列函数称为密码散列函数。具有**单向性**的特点。要找到两个不同的报文，它们具有同样的密码散列函数输出，在计算上是不可行的。也就是说，**密码散列函数实际上是一种单向函数** (one-way function)。
#### ②密码散列函数MD5和SHA
SHA-1比 MD5 更安全，但计算起来却比 MD5 要慢些。
##### MD5报文摘要算法
基本思想：用足够复杂的方法将报文的数据位充分“弄乱”，报文摘要代码中的**每一位**都与**原来报文中的每一位有关**。      
MD5 实现的报文鉴别**可以防篡改**，但**不能防伪造**，因而不能真正实现报文鉴别。
**计算步骤**：
1. 附加：把任意长的报文按模264计算其余数（64位），追加在报文的后面（长度项）。
2. 填充：在报文和长度项之间填充 1～512 位，使得填充后的总长度是 512 的整数倍。填充的首位是 1，后面都是 0。
3. 分组：把追加和填充后的报文分割为一个个 512 位的数据块，每个 512 位的报文数据再分成 4 个 128 位的数据块。
4. 计算：将 4 个 128 位的数据块依次送到不同的散列函数进行 4 轮计算。每一轮又都按 32 位的小数据块进行复杂的运算。一直到最后计算出 MD5 报文摘要代码（128 位）。
##### SHA 安全散列算法
已制定 SHA-1、SHA-2、 SHA-3 等版本
#### ③报文鉴别码MAC
D5 实现的报文鉴别可以**防篡改**，但**不能防伪造**，因而不能真正实现报文鉴别。
例如：
1. 入侵者创建了一个伪造的报文 M，然后计算出其散列 H(M )，并把拼接有散列的扩展报文冒充 A 发送给 B。
2. B 收到扩展的报文 (M, H(M )) 后， 通过散列函数的运算，计算出收到的报文 MR 的散列 H(MR)。
3. 若 H(M ) = H(MR)，则 B 就会误认为所收到的伪造报文就是 A 发送的。

为防范上述攻击，可以**对散列进行一次加密**。散列加密后的结果叫做**报文鉴别码 MAC** (Message Authentication Code)。由于入侵者不掌握密钥 K，所以入侵者无法伪造 A 的报文鉴别码 MAC，因而无法伪造 A 发送的报文。这样就**完成了对报文的鉴别**。

所以现在**整个**的报文是**不需要加密**的。虽然从散列 H 导出报文鉴别码 MAC 需要加密算法，但由于散列 H 的长度通常都远远小于报文 X 的长度，因此这种加密**不会消耗**很多的计算资源。因此，使用**鉴别码 MAC 就能够很方便地保护报文的完整性**。
### 6.4.2 实体鉴别
报文鉴别是对**每一个**收到的**报文**都要鉴别报文的发送者。**实体鉴别**是在系统接入的全部持续**时间内**对和自己通信的对方实体**只需验证一次**。     
使用不重数进行鉴别

在使用公钥密码体制时，可以对**不重数**进行签名鉴别。     
B 用其**私钥对不重数** **RA** 进行签名后发回给 A。A 用 B 的公钥核实签名。如能得出自己原来发送的不重数 **RA**，就核实了和自己通信的对方的确是 B。同样，A 也用自己的**私钥对不重数** **RB** 进行签名后发送给 B。B 用 A 的公钥核实签名，鉴别了 A 的身份。
## 6.5 密钥分配
### 6.5.1 对称密钥的分配
目前常用的密钥分配方式是设立**密钥分配中心 KDC** (Key Distribution Center)。其任务就是给需要进行秘密通信的用户临时分配一个会话密钥（**仅使用一次**）。(前最出名的**密钥分配协议是 Kerberos V5**。)

为防止重放攻击，KDC 还可在报文中加入**时间戳**。会话密钥 KAB 是**一次性**的，因此保密性较高。KDC 分配给用户的密钥 KA 和 KB，应**定期更换**，以减少攻击者破译密钥的机会。
### 6.5.2 公钥的分配
如果**每个用户都具有其他用户的公钥**，就可实现安全通信。但不能随意公布用户的公钥，因为无法防止假冒和欺骗。使用者也无法确定公钥的真正拥有者。需要有一个值得信赖的机构——**即认证中心 CA** (Certification Authority)，来将**公钥**与其对应的**实体**（人或机器）进行**绑定** (binding)。每个**实体**都有 **CA  发来的证书** (certificate)，里面有公钥及其拥有者的标识信息。此证书被 CA 进行了数字签名，是不可伪造的，可以信任。证书是一种身份证明，用于解决**信任问题**。
## 6.6 安全协议
### 6.6.1 网络层安全协议
IP安全性很差：
- IP 几乎不具备任何安全性，**不能保证**：数据机密性、数据完整性、数据来源认证。
- 由于其在设计和实现上存在安全漏洞，使各种攻击有机可乘。例如：攻击者很容易构造一个包含虚假地址的 IP 数据报。
- **IPsec** 提供了标准、健壮且包含广泛的机制保证 IP 层安全。
#### ① IPsec协议族概述
IP安全(security).IPsec 并不是一个单个的协议，而是能够在 IP 层提供互联网通信安全的**协议族**。IPsec 是个框架，它允许通信双方选择合适的算法和参数（例如，密钥长度）。为保证互操作性，IPsec 还包含了所有 IPsec 的实现都必须有的一套**加密算法**。
##### 组成
1. IP安全数据报格式的两个协议
  - 鉴别首部AH(Authentication Header)协议
  - 装安全有效载荷ESP(Encapsulation Security Payload)协议
2. 有关加密算法的三个协议
3. 互联网密钥交换IKE(Internet Key Exchange) 协议
AH 协议提供源点鉴别和数据完整性，但不能保密。ESP 协议比 AH 协议复杂得多，它提供源点鉴别、数据完整性和保密。AH 协议的功能都已包含在 ESP 协议中。
#### ② IP安全数据报的工作方式
##### 运输方式
在**整个运输层报文段**的前后分别添加若干**控制信息**，再加上IP首部。**构成IP安全数据报**。适合于主机到主机之间的安全传送。需要使用IPsec的主机都运行IPsec协议。

隧道方式常用来**实现虚拟专用网 VPN** 的加密。无论使用哪种方式，最后得出的 IP 安全数据报的**IP首部都是不加密**的。所谓“安全数据报”是指数据报的**数据部分是经过加密**的，并能够被鉴别的。通常把数据报的数据部分称为数据报的有效载荷 (payload)。
#### ③ 安全关联
在发送 IP 安全数据报之前，在源实体和目的实体之间必须创建一条**网络层的逻辑连接**。此逻辑连接叫做**安全关联** SA (Security Association) 。**IPsec** 就把传统互联网无连接的网络层**转换为具有逻辑连接的网络层**。

安全关联是从源点到终点的**单向连接**，它能够提供安全服务。在安全关联 SA 上传送的就是 **IP 安全数据报**。如要进行双向安全通信，则两个方向都需要建立安全关联。若 n 个员工进行双向安全通信，一共需要创建 (2 + 2n ) 条安全关联 SA。
#### ④ IP 安全数据报的格式
<img src="assets/1574756486826.png" alt="1574756486826" style="zoom:60%;" />
### 6.6.2 运输层安全协议
#### ① 概述
- 安全套接字层协议SSL(Secure Socket Layer)
- 运输层安全TLS协议(Transport Layer Security)

SSL 作用在端系统应用层的**HTTP和运输层**之间,在**TCP之上建立起一个安全通道**，为通过**TCP传输的应用层**数据提供安全保障。在**SSL**3.0**基础**上推出了**传输层安全标准TLS**，为**所有基于TCP的网络应用**提供安全数据传输服务。

在**发送方**，SSL 接收**应用层**的数据，对数据进行**加密**，然后把加了密的数据送往**TCP 套接字**。在**接收方**SSL从**TCP**套接字**读取**数据，解密后把数据交给应用层。

应用程序 HTTP 调用**SSL对整个网页**进行加密时，网页上会提示用户，在网址栏原来显示 http 的地方，现在变成了**https**。在 http后面加上的 s 代表**security**，表明现在使用的是提供安全服务的 HTTP 协议（TCP 的 HTTPS 端口号是**443**，而不是平时使用的端口号 80）。
##### SSL 提供的安全服务
- SSL服务器鉴别：允许用户证实服务器的身份。支持SSL的客户端通过验证来自服务器的证书，来鉴别服务器的真实身份并获得服务器的公钥。
- SSL客户鉴别：SSL 的可选安全服务，允许服务器证实客户的身份。
- 加密的SSL会话：对客户和服务器间发送的所有报文进行加密，并检测报文是否被篡改。

#### ② SSL安全会话建立过程
1. 协商加密算法
  - 浏览器 A 向服务器 B 发送浏览器的 SSL 版本号和一些可选的加密算法。
  - B 从中选定自己所支持的算法（如 RSA），并告知 A。
2. 服务器鉴别
  - 服务器 B 向浏览器 A 发送包含其 RSA 公钥的数字证书
  - A 使用该证书的认证机构 CA 公开发布的RSA公钥对该证书进行验证
3. 会话密钥计算
  - 由浏览器 A 随机产生一个秘密数。用服务器 B 的 RSA 公钥进行加密后发送给 B
  - 双方根据协商的算法产生共享的对称会话密钥。
3. 安全数据传输
  - 双方用会话密钥加密和解密它们之间传送的数据并验证其完整性

### 6.6.3 应用层安全协议
本节仅讨论应用层中有关**电子邮件**的安全协议。发送电子邮件是个即时的行为。发送方 A 和接收方 B 并不会为此而建立任何会话。电子邮件安全协议就应当为每种加密操作定义相应的算法，以及密钥管理、鉴别、完整性保护等方法。

## 6.7 防火墙与入侵检测
### 6.7.1 防火墙
防火墙是由软件、硬件构成的系统，是一种特殊编程的**路由器**，用来在两个网络之间实施访问控制策略。访问控制策略是由使用防火墙的单位自行制订的，为的是可以最适合本单位的需要。防火墙内的网络称为“可信的网络”(trusted network)，而将外部的互联网称为“不可信的网络”(untrusted network)。防火墙可用来解决**内联网和外联网**的安全问题。

防火墙的功能：
- “阻止”就是阻止某种类型的通信量通过防火墙
- “允许”的功能与“阻止”恰好相反。

防火墙技术分为一般两类：
- 分组过滤路由器
  - 是一种具有分组过滤功能的路由器，它根据过滤规则对进出内部网络的分组执行转发或者丢弃（即过滤）。过滤规则基于分组的网络层或运输层首部的信息，例如：源/目的 IP 地址、源/目的端口、协议类型（TCP 或 UDP）等。
  - 分组过滤可以是无状态的，即独立地处理每一个分组。也可以是有状态的，即要跟踪每个连接或会话的通信状态，并根据这些状态信息来决定是否转发分组。
  - 简单高效，对用户透明，但不能对高层数据进行过滤。
- 应用网关也称为代理服务器 (proxy server)
  - 它在应用层通信中扮演报文中继的角色。
  - 每种网络应用需要一个应用网关。
  - 可以实现基于应用层数据的过滤和高层用户鉴别。
  - 所有进出网络的应用程序报文都必须通过应用网关。
  - 应用网关也有一些缺点：每种应用都需要一个不同的应用网关；在应用层转发和处理报文，处理负担较重；对应用程序不透明，需要在应用程序客户端配置应用网关地址。
### 6.7.2 入侵检测
防火墙试图在入侵行为发生之前阻止所有可疑的通信。**入侵检测系统 IDS** (Intrusion Detection System) 能够在入侵已经开始，但还没有造成危害或在造成更大危害前，及时检测到入侵，以便尽快阻止入侵，把危害降低到最小。

IDS 对进入网络的分组执行深度分组检查，当观察到可疑分组时，向网络管理员发出告警或执行阻断操作（由于 IDS 的“误报”率通常较高，多数情况不执行自动阻断）。IDS 能用于**检测多种网络攻击**，包括网络映射、端口扫描、DoS 攻击、蠕虫和病毒、系统漏洞攻击等。

## 6.8 Web 攻击技术
- XSS攻击：关键是脚本，利用恶意脚本发起攻击
- CSRF攻击：关键是借助本地 cookie 进行认证，伪造发送请求
- SQL注入：关键是通过用 SQL 语句伪造参数发出攻击
- DDOS攻击：关键是发出大量请求，最后令服务器崩溃
### 6.8.1 跨站脚本攻击XSS(Cross-Site Scripting, XSS)
#### ① 概念及攻击原理
可以将代码注入到用户浏览的网页上，这种代码包括 HTML 和 JavaScript。从而达到攻击的目的，如盗取用户的 cookie，改变网页的 DOM 结构，重定向到其他网页等。XSS 的攻击方式就是想办法“教唆”**用户的浏览器去执行一些这个网页中原本不存在的前端代码**。
#### ②攻击分类
1. 反射型XSS;又称为非持久性跨站点脚本攻击，它是最常见的类型的XSS。漏洞产生的原因是攻击者注入的数据反映在响应中。一个典型的非持久性XSS包含一个带XSS攻击向量的链接(即每次攻击需要用户的点击)。
2. 持久型XSS;又称为持久型跨站点脚本，它一般发生在XSS攻击向量(一般指XSS攻击代码)存储在网站数据库，当一个页面被用户打开的时候执行。每当用户打开浏览器,脚本执行。持久的XSS相比非持久性XSS攻击危害性更大,因为每当用户打开页面，查看内容时脚本将自动执行。

# 7. HTTP
## 7.1 URI与URL
### 7.1.1 概念
- URI：统一资源标识符
- URL：统一资源定位符

URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。
### 7.1.2 URL的一般格式
```
<协议>://<主机>:<端口>/<路径>
```
- 协议：FTP：文件传输协议； HTTP：超文本传输协议
- ://：固定格式
- 主机：存放资源的主机，在互联网中的域名或IP地址
- 端口路径：指明资源具体路径

## 7.2 请求和响应报文
由于 HTTP 是面向正文的 (text-oriented)，因此在报文中的每一个字段都是一些 **ASCII 码串**，因而每个字段的长度都是不确定的。
### 7.2.1 请求报文
开始行、首部行、实体主体。请求报文中开始行就是请求行。

GET 请求的参数直接在 URL 中，没有请求体，而 POST 请求的参数通常在请求体中。
### 7.2.2 响应报文
响应报文的开始行是状态行，包括三项：HTTP的版本，状态码，以及解释状态码的简单短语

## 7.3 HTTP方法
客户端发送的**请求报文**第一行为请求行，包含了**方法**字段

|    方法     |          说明          | 支持的HTTP协议版本 |
| :---------: | :--------------------: | :----------------: |
|   **GET**   |      **获取资源**      |      1.0、1.1      |
|  **POST**   |    传输实**体主体**    |      1.0、1.1      |
|   **PUT**   |        传输文件        |      1.0、1.1      |
|  **HEAD**   |    获得报文**首部**    |      1.0、1.1      |
| **DELETE**  |        删除文件        |      1.0、1.1      |
| **OPTIONS** |     询问支持的方法     |        1.1         |
|  **TRACE**  |        追踪路径        |        1.1         |
| **CONNECT** | 要求用隧道协议连接代理 |        1.1         |

LINK 和 UNLINK 已被 HTTP/1.1 **废弃**。
### 7.3.1 GET
请求访问已被 URI 识别的资源。当前网络请求中，绝大部分使用的是 GET 方法
### 7.3.2 POST
传输实体的主体。POST 主要用来**传输数据**，而 GET 主要用来获取资源。
### 7.3.3 PUT
上传文件。由于自身不带验证机制，任何人都可以上传文件，因此**存在安全性**问题，一般**不使用**该方法。
### 7.3.4 HEAD
获取**报文首部**。和 GET 方法类似，但是**不返回报文实体主体**部分。主要用于确认 URL 的有效性以及资源更新的日期时间等。
### 7.3.5 PATCH
对资源进行**部分修改**。PUT 也可以用于**修改资源**，但是只能**完全替代**原始资源，PATCH 允许**部分修改**。
### 7.3.6 DELETE
删除文件。与 PUT 功能相反，并且同样**不带验证**机制。
### 7.3.7 OPTIONS
查询**支持的方法**。查询指定的 URI 能够**支持的方法**。会返回 `Allow: GET, POST, HEAD, OPTIONS` 这样的内容。
### 7.3.8 CONNECT
要求在与代理服务器通信时**建立隧道**。使用 **SSL**（Secure Sockets Layer，安全套接层）和 **TLS**（Transport Layer Security，传输层安全）协议把通信内容**加密**后经网络隧道传输。实现用隧道协议进行 TCP 通信。
### 7.3.9 TRACE
**追踪路径**
服务器会将**通信路径**返回给客户端。发送请求时，在 Max-Forwards 首部字段中填入数值，每经过一个服务器就会减 1，当数值为 0 时就停止传输。通常不会使用 TRACE，并且它容易受到 **XST** 攻击（Cross-Site Tracing，跨站追踪）

## 7.4 HTTP状态码
服务器返回的  **响应报文**  中第一行为**状态行**，包含了状态码以及原因短语，用来告知客户端请求的结果。常用 14 种

| 状态码  |                 类别                 |            含义            |
| :-----: | :----------------------------------: | :------------------------: |
| **1XX** |  Informational（**信息性**状态码）   |     接收的请求正在处理     |
| **2XX** |      Success（**成功**状态码）       |      请求正常处理完毕      |
| **3XX** |   Redirection（**重定向**状态码）    | 需要进行附加操作以完成请求 |
| **4XX** | Client Error（**客户端错误**状态码） |     服务器无法处理请求     |
| **5XX** | Server Error（**服务器错误**状态码） |     服务器处理请求出错     |

### 7.4.1 1XX 信息
-  **100 Continue** ：表明到目前为止都很正常，客户端可以继续发送请求或者**忽略**这个响应。
### 7.4.2 2XX 成功
- **200 OK** ：成功。
- **204 No Content** ：请求已经**成功处理**，但是返回的响应报文**不包含实体的主体**部分。一般在只需要从客户端往服务器发送信息，而不需要返回数据时使用。
- **206 Partial Content**：表示客户端进行了**范围请求**，响应报文包含由 Content-Range 指定范围的实体内容。
### 7.4.3 3XX 重定向
- **301 Moved Permanently**：**永久性** 重定向。
- **302 Found** ：**临时性** 重定向。
- **303 See Other** ：和 302 有着相同的功能，但是 303 明确要求客户端应该采用 GET 方法获取资源。注：虽然 HTTP 协议规定 301、302 状态下重定向时不允许把 POST 方法改成 GET 方法，但是大多数浏览器都会在 301、302 和 303 状态下的重定向把 POST 方法改成 GET 方法。
- **304 Not Modified** ：如果**请求报文**首部包含**一些条件**，例如：**If-Match，If-Modified-Since，If-None-Match，If-Range，If-Unmodified-Since**，如果**不满足**条件，则服务器会返回 **304 状态码**。（其实这与重定向**没有**关系）。
- **307 Temporary Redirect** ：临时重定向，与 302 的含义类似，但是 307 要求浏览器**不会**把重定向请求的 POST 方法改成 GET 方法。
### 7.4.4 4XX 客户端错误
- **400 Bad Request** ：请求报文中存在**语法错误**。
- **401 Unauthorized** ：**未认证**。该状态码表示发送的请求需要有**认证信息**（BASIC 认证、DIGEST 认证）。如果之前已进行过一次请求，则表示用户认证失败。
- **403 Forbidden** ：请求被服务器**拒绝**。
- **404 Not Found** ：资源未找到。
### 7.4.5 5XX 服务器错误
- **500 Internal Server Error** ：服务器正在**执行请求时**发生错误。
- **503 Service Unavailable** ：服务器暂时处于**超负载**或正在进行**停机维护**，现在无法处理请求。

## 7.5 HTTP首部
有 4 种类型的首部字段：**通用首部字段、请求首部字段、响应首部字段和实体首部字段**。

表示方式：
```
首部字段名：首部字段值
```
字段值对应单个 HTTP 首部字段可以有**多个**值：
```http
cache-control: public, max-age=0
```
### 7.5.1 通用首部字段
通用首部字段是请求与响应**都可以**使用的字段。

|    首部字段名     |                    说明                    |
| :---------------: | :----------------------------------------: |
| **Cache-Control** |             控制**缓存**的行为             |
|    Connection     | 控制不再转发给代理的首部字段、管理持久连接 |
|       Date        |           创建报文的**日期**时间           |
|      Pragma       |                报文**指令**                |
|      Trailer      |             报文末端的首部一览             |
| Transfer-Encoding |         指定报文主体的传输编码方式         |
|      Upgrade      |               升级为其他协议               |
|        Via        |            代理服务器的相关信息            |
|      Warning      |                  错误通知                  |

#### 1. Cache-Control
通过指定首部字段 Cache-Control 的指令，就能操作**缓存**的工作机制。指令的参数是可选的，多个指令之间通过“,”分隔。首部字段 Cache-Control 的指令可用于请求及响应时。
```http
Cache-Control: private, max-age=0, no-cache
```
**缓存请求指令**
| 指令                  | 参数   | 说明                           |
| --------------------- | ------ | ------------------------------ |
| **no-cache**          | 无     | 强制向源服务器**再次验证**     |
| **no-store**          | 无     | **不缓存**请求或响应的任何内容 |
| **max-age = [ 秒]**   | 必需   | 响应的最大Age值                |
| max-stale( = [ 秒])   | 可省略 | 接收已过期的响应               |
| **min-fresh = [ 秒]** | 必需   | 期望在指定时间内的响应仍有效   |
| no-transform          | 无     | 代理不可更改媒体类型           |
| only-if-cached        | 无     | 从缓存获取资源                 |
| cache-extension       | -      | 新指令标记（token）            |
换言之，无参数值的首部字段可以使用缓存。从字面意思上很容易把 no-cache **误解**成为不缓存，但事实上 **no-cache 代表不缓存过期的资源**，缓存会向源服务器进行有效期确认后处理资源，也许称为 do-notserve-from-cache-without-revalidation 更合适。**no-store才是真正地不进行缓存**，请读者注意区别理解。
#### 2. Connection
- ① 控制**不再转发给代理**的首部字段
- ② 管理**持久**连接
HTTP1.1 之前默认不是持久连接，如果要持久连接需要设置为 Keep-Alive。

```http
Connection : Keep-Alive
```
#### 3. Transfer-Encoding
规定了传输报文主体时采用的**编码方式**（仅对分块传输编码有效）
#### 4. Upgrade
用于检测 HTTP 协议及其他协议是否可使用**更高的版本**进行通信，其参数值可以用来指定一个完全不同的通信协议（仅限与客户端和临接服务器之间，因此使用首部字段 Upgrade 时还需要额外指定 connection：Upgrade）

使用 **WebSocket** 需要**切换协议**使用这个。
#### 5. Via
为了追踪客户端和服务器之间的请求和响应报文的传输路径。当报文经过**代理或网关**时，会先在**首部字段 Via 中附加**该服务器的信息，然后在进行转发。多与 TRACE 方法一起使用。

各个代理服务器会往Via首部添加自身服务器的信息。
### 7.5.2 请求首部字段
是从客户端往服务器端发送**请求报文**中所使用的字段，用于补充请求的附加信息、客户端信息、对响应内容相关的优先级等内容。
|     首部字段名      |                      说明                       |
| :-----------------: | :---------------------------------------------: |
|     **Accept**      |        **用户**代理可处理的**媒体类型**         |
|   Accept-Charset    |                  优先的字符集                   |
|   Accept-Encoding   |                 优先的内容编码                  |
|   Accept-Language   |             优先的语言（自然语言）              |
|  **Authorization**  |      **Web 认证信息**（可存放 **Token**）       |
|       Expect        |              期待服务器的特定行为               |
|        From         |               用户的电子邮箱地址                |
|      **Host**       |               请求资源所在服务器                |
|    **If-Match**     |              比较实体标记（ETag）               |
|  If-Modified-Since  |               比较资源的更新时间                |
|    If-None-Match    |        比较实体标记（与 If-Match 相反）         |
|      If-Range       |      资源未更新时发送实体 Byte 的范围请求       |
| If-Unmodified-Since | 比较资源的更新时间（与 If-Modified-Since 相反） |
|    Max-Forwards     |                 最大传输逐跳数                  |
| Proxy-Authorization |         代理服务器要求客户端的认证信息          |
|        Range        |               实体的字节范围请求                |
|     **Referer**     |          对请求中 URI 的**原始获取方**          |
|         TE          |                传输编码的优先级                 |
|     User-Agent      |              HTTP 客户端程序的信息              |
#### 1. Accept
通知服务器，用户代理能够处理的媒体类型及媒体类型的相对优先级，可以使用 q=num 来代表**权重的优先值**，权重值 num 的取值范围是0-1，可以精确到三位小数，1为权重最大值，默认为1.
> Accept: text/html,application/json;q=0.9, application/xml;q=0.8

#### 2. Accept-Charset
首部字段可用来通知服务器用户代理支持的字符集及字符集的相对优先顺序，权重用法同 Accept 字段的 q。
#### 3. Accept-Encoding
首部字段可用来通知服务器用户代理支持的内容编码及编码的优先级，可以一次性指定多种内容编码,采用权重q表示优先级。
```
Accept-Encoding: gzip, deflate, cpmpress, identity
```
#### 4. Accept-Language
首部字段用来告知服务器，用户代理能够处理的语言，采用权重 q 指定优先级
#### 5. Authorization
用来告知服务器用户代理的**认证信息**， 用于验证用户身份的凭证。使用 Token 认证时，将 Token 放在这个首部字段下。
#### 6. Host
指明请求服务器的**域名**， 及服务器所**监听的 Tcp 端口号**，如果没有给定端口，会自动使用被请求服务的默认端口， 用于告知服务器请求资源所处的服务器域名及端口号。**唯一一个必须被包含在请求内的首部字段**。如果一个 IP 对应多个域名， 那就用 Host 字段指明服务器主机。
#### 7. 条件请求
> 形如 **if-XXXX** 的请求首部字段，都是**条件请求**，服务器接收到附带的请求条件后，只有**当条件满足时**，服务器才会执行

#### 8. if-Match
通常在请求方法为 GET 时，服务器仅在请求资源的 ETag 值为 if-Match 首部字段值之一时，才会返回资源，当请求方法为 PUT 时，才允许上传资源。ETag 为一份资源独一无二的实体标记，资源更新后实体标记值 ETag 也会更新。
#### 9. if-Modified-since
通常该字段只用在 GET 请求中，如果资源在 if-Modified-Since 字段值日期之后发生更新，则服务器接受该请求， 否则会返回一个不带响应体的 304（Not Modified），用于确认代理或客户端本地资源的有效性。
#### 10. if-None-Match
当且仅当服务器上没有任何资源的实体标记 ETag 值与该首部字段中列出的值相对应时，服务器才会返回所请求的资源，否则返回 304。
#### 11. if-Range
范围请求。用来当满足条件时（当 if-range 字段值中的条件得到满足，通常是满足 last-Modified 或 ETag），是 Range 字段起作用，服务器返回 206 Partial Content，如果 if-Range 字段值中的条件没有得到满足，则作为正常处理返回 200 OK 的**全部**资源。
#### 12. Proxy-Authorization
用于用户代理给代理服务器发送身份验证的凭证。
```jsx
Proxy-Authorization: Basic YWxhZGRpbjpvcGVuc2VzYW1l
```
#### 13. Range
用于只需获取部分资源的**范围请求**，字段值表明服务器资源的指定范围。
```xml
Range: <unit>=<range-start>-<range-end>, <range-start>-<range-end>
```
#### 14. Referer
可以根据 Referer 查看请求资源的是从**哪个页面**发起的。
#### 15. TE
告知服务器客户端能够处理响应的传输编码方式以及相对优先级。
#### 16. User-Agent
将创建请求的浏览器和用户代理信息等名称传达给服务器。**爬虫** 必备。

### 7.5.3 响应首部字段
响应首部字段是由服务器端向客户端返回**响应报文**中所使用的字段，用于补充响应的附加信息、服务器信息、以及对客户端的附加要求信息。
|      首部字段名      |             说明             |
| :------------------: | :--------------------------: |
|    Accept-Ranges     |   是否接受字节**范围请求**   |
|       **Age**        |   推算资源**创建**经过时间   |
|       **ETag**       |      资源的**匹配信息**      |
|       Location       |   令客户端重定向至指定 URI   |
|  Proxy-Authenticate  | 代理服务器对客户端的认证信息 |
|     Retry-After      |   对再次发起请求的时机要求   |
|      **Server**      |  HTTP 服务器的**安装信息**   |
|       **Vary**       | 代理**服务器缓存**的管理信息 |
| **WWW-Authenticate** | 服务器对客户端的**认证信息** |

#### 1. Accept-Ranges
用于告知客户端服务器能否处理范围请求。
```swift
Accept-Ranges: none | bytes    // none就是不能
```
#### 2. Age
能告知客户端，源服务器在**多久前**创建了响应，字段值的单位为秒。
#### 3. ETag
它是一种将资源以字符串的形式做唯一标识性的方式，服务器会为每份资源分配对应的ETag值，当资源更新时，ETag值也会更新。没有特定的生成算法，通常使用资源最后修改时间戳的哈希值，或散列或版本号。       
用处：
1. 防止资源的同时更新而导致的相互覆盖（空中碰撞）
2. 缓存未更改的资源。
#### 4. Location
指定需要将页面**重新定向**至的地址。
#### 5. Proxy-Authenticate
会把由代理服务器所要求的认证信息发送给客户端。指定了获取代理服务器上的资源访问权限而采用的身份验证方式。代理服务器对请求进行验证，以便它进一步传递请求。
#### 6. Retry-After
告知客户端应该在多久后可以再次发起请求。主要配合状态码 **503**（Service Unavailable）响应。
#### 7. Server
首部字段 Server 告知客户端当前服务器上安装的 HTTP 服务器应用程序的信息。
#### 8. Vary
当代理服务器接收到带有 Vary 首部字段指定获取资源的请求时，如果使用的 Accept-Language 字段的值相同，那么就直接从源服务器返回响应，反之，则需要先从源服务器获取资源后才能作为响应返回。
### 7.5.4 实体首部字段
实体首部字段是包含在请求报文和响应报文中的**实体部分所使用的首部**，用于补充内容的更新时间与实体相关的信息。请求报文和响应报文中都含有的与实体相关的首部。
|    首部字段名    |            说明             |
| :--------------: | :-------------------------: |
|    **Allow**     | 资源可**支持的 HTTP 方法**  |
| Content-Encoding |   实体主体适用的编码方式    |
| Content-Language |     实体主体的自然语言      |
|  Content-Length  | 实体主体部分的大小（bites） |
| Content-Location |     替代对应资源的 URI      |
|   Content-MD5    |     实体主体的报文摘要      |
|  Content-Range   |     实体主体的位置范围      |
|   Content-Type   |     实体主体的媒体类型      |
|   **Expires**    | 实体主体**过期的日期**时间  |
|  Last-Modified   |   资源的最后修改日期时间    |

#### 1. ALlow
由于枚举资源所支持的 HTTP 方法的**集合**，当服务器接收到不支持的HTTP方法时，会返回 **405**（Method Not Allowed ）作为响应返回，于此同时还会把**所有能支持**的 HTTP 方法写入首部字段 Allow 返回。
```http
Allow: GET, POST, HEAD
```
#### 2. Content-Encoding
告知客户端服务器对实体的**主体部分**选用的内容**编码**方式。（内容编码是指在不丢失实体信息的前提下所进行的压缩）常用的有 gzip、compress、deflate、 identify;
#### 3. Content-Language
告知客户端实体主体使用的自然语言。
```http
Content-Language: zh-CN
```
#### 4. Content-Location
首部字段 Content-Location 给出与报文主体部分相对应的 URI。和首部字段 Location 不同，Content-Location 表示的是报文主体返回的资源对应的 URI。
#### 5. Content-type
说明了实体主体部分的**媒体类型**，和首部字段 Accept 一样，字段值用 type/subtype 形式赋值
#### 6. Expires
会将**资源失效的日期**告知客户端，缓存服务器在接收到含有首部字段 Expires 的响应后，会以缓存来应答请求，在 Expires 字段值指定的时间之前，响应的副本会一直保存，当超过指定的时间后，缓存服务器在请求发送过来时，会转向源服务器请求资源。

## 7.6 HTTP应用
### 7.6.1 用单台虚拟主机实现多个域名
HTTP/1.1 规范允许一台 HTTP 服务器搭建多个 web 站点。即使物理层面只有一台服务器，但只要使用**虚拟主机**的功能，则可以假想已具有**多台服务器**。

在互联网上，域名通过 DNS 服务映射到 IP 地址（域名解析）之后访问目标网站。可见，当请求发送到服务器时，已经是以 IP 地址形式访问了。所以，如果一台服务器内托管了 www.tricorder.jp 和 www.hackr.jp 这两个域名，当收到请求时就需要弄清楚究竟要访问哪个域名。一个 IP 地址可能对应多个域名。在相同的IP地址下，由于虚拟主机可以寄存多个不同主机名和域名的 web 网站，因此在发送 HTTP 请求时，必须在 **Host首部**内完整指定主机名或域名的**URI**。
### 7.6.2 代理、网关、隧道
这些应用程序和服务器可以将请求转发给通信线路上的下一站服务器，并且接收从那台服务器发送的响应再转发给客户端。
#### ① 代理
代理服务器的基本行为就是接收客户端发送的请求后**转发**给其他服务器。代理**不改变**请求 URI，会直接发送给前方持有资源的目标服务器。持有资源实体的服务器被称为**源服务器**。从源服务器返回的响应经过代理服务器后再传给客户端。每次 经过代理服务器转发请求或响应时，会**追加写入 Via 首部**信息。

代理一般按两种基准分类：一是是否使用缓存，二是是否会修改报文。

透明代理：不对报文做任何修改。

**缓存代理**：会预先将资源的副本缓存保存在代理服务器上，会定期检查资源的有效性。当代理再次接收到对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回。

使用代理服务器的理由有：利用缓存技术减少网络带宽的流量，组织内部针对特定网站的访问控制，以获取访问日志为主要目的等等。即：
- 缓存
- 负载均衡
- 网络访问控制
- 访问日志记录

代理服务器分为**正向代理和反向代理**两种：
- 用户察觉得到正向代理的**存在**
- 而反向代理一般位于**内部网络**中，用户察觉**不到**
#### ② 网关
网关的工作机制和代理十分相似。而网关能使通信线路上的服务器提供**非 HTTP 协议**服务。利用网关能提供通信的安全性，因为可以在客户端与网关之间的通信线路上加密以确保连接的安全。

#### ③ 隧道
隧道可按要求建立起一条与其他服务器的通信线路，届时使用 SSL 等加密手段进行通信。隧道的目的是确保客户端能与服务器进行安全通信。

隧道本身**不会去解析** HTTP 请求。也就是说，请求保持原样中转给之后的服务器。隧道会在通信双方断开连接时结束。

### 7.6.3 连接管理
#### ① 短连接与长连接
在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。

而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：
```javascript
Connection:keep-alive
```
在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。

HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。当浏览器访问一个包含多张图片的 HTML 页面时，除了请求访问的 HTML 页面资源，还会请求图片资源。如果每进行一次 HTTP 通信就要新建一个 TCP 连接，那么开销会很大。

**长连接**只需要建立一次 TCP 连接就能进行**多次 HTTP 通信**。
![image-20191229153753544](assets/image-20191229153753544.png)
- 从 **HTTP/1.1** 开始**默认是长连接**的，如果要断开连接，需要由**客户端或者服务器端提出断开**，使用 `Connection : close`；
- 在 HTTP/1.1 之前默认是**短连接**的，如果需要使用**长连接**，则使用 `Connection : Keep-Alive`。
#### ② 流水线
默认情况下，HTTP 请求是按**顺序**发出的，下一个请求只有在当前请求**收到响应之后**才会被发出。由于受到网络延迟和带宽的限制，在下一个请求被发送到服务器之前，可能需要等待很长时间。

而**流水线**是在同一条长连接上连续发出请求，而不用等待响应返回，这样可以减少延迟。

### 7.6.4 Cookie
HTTP 协议是**无状态**的，主要是为了让 HTTP 协议尽可能简单，使得它能够处理大量事务。HTTP/1.1 引入 Cookie 来**保存状态信息**。

> 如何理解HTTP协议是无状态的？
```
HTTP协议是无状态的（stateless），指的是协议对于事务处理没有记忆能力，服务器不知道客户端是什么状态。也就是说，打开一个服务器上的网页和上一次打开这个服务器上的网页之间没有任何联系。HTTP是一个无状态的面向连接的协议，无状态不代表HTTP不能保持TCP连接，更不能代表HTTP使用的是UDP协议（无连接）。

缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就较快。
```

Cookie 是**服务器**发送到**用户浏览器**并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被**携带**上，用于告知服务端两个请求是否来自同一浏览器。由于之后**每次请求都会需要携带** Cookie 数据，因此会带来额外的性能开销（尤其是在移动环境下）。

Cookie 曾一度用于客户端数据的存储，因为当时并没有其它合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，Cookie 渐渐被**淘汰**。新的浏览器 API 已经允许开发者直接将数据存储到本地，如使用 **Web storage API**（本地存储和会话存储）或 **IndexedDB**。
#### ① 用途
- 会话状态管理(如用户登录状态、购物车、游戏分数或其它需要记录的信息)
- 个性化设置(如用户自定义设置、主题等)
- 浏览器行为跟踪(如跟踪分析用户行为等)
#### ② 创建过程
服务器发送的**响应报文**包含**Set-Cookie**首部字段，客户端得到响应报文后把**Cookie**内容保存到浏览器中。
```http
HTTP/1.0 200 OK
Content-type: text/html
Set-Cookie: yummy_cookie=choco			// 设置cookie信息
Set-Cookie: tasty_cookie=strawberry		// 设置cookie信息
[page content]
```
客户端之后对同一个服务器发送请求时，会从浏览器中取出 Cookie 信息并**通过 Cookie 请求首部字段**发送给服务器。
```http
GET /sample_page.html HTTP/1.1
Host: www.example.org
Cookie: yummy_cookie=choco; tasty_cookie=strawberry		// 请求时携带cookie信息
```
#### ③ 分类
- 会话期Cookie：浏览器**关闭**之后它会被**自动删除**，也就是说它仅在会话期内有效。
- 持久性Cookie：指定**过期时间**（**Expires**）或有效期（**max-age**）之后就成为了持久性的 Cookie。
```http
Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;	// 指定了cookie的过期时间
```
#### ④ 作用域
Domain 标识指定了哪些**主机**可以接受 Cookie。如果不指定，默认为当前文档的主机（不包含子域名）。如果指定了 Domain，则一般包含子域名。例如，如果设置 Domain=mozilla.org，则 Cookie 也包含在子域名中（如 developer.mozilla.org）

而**Path 标识**指定了主机下的哪些路径可以接受 Cookie（该 URL 路径必须存在于请求 URL 中）。以字符 %x2F ("/") 作为路径分隔符，子路径也会被匹配。例如，设置 Path=/docs，则以下地址都会匹配：
- /docs
- /docs/Web/
- /docs/Web/HTTP
#### ⑤ HttpOnly
浏览器通过 `document.cookie` 属性可**创建新的 Cookie**，也可通过该属性访问**非 HttpOnly 标记**的 Cookie。标记为**HttpOnly**的 Cookie**不能被 JavaScript 脚本调用**。**跨站脚本攻击 (XSS)** 常常使用 JavaScript 的 `document.cookie` API 窃取用户的 Cookie 信息，因此使用 HttpOnly 标记可以在一定程度上避免**XSS 攻击**。
```http
Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly
```
#### ⑥ Secure
标记为 Secure 的 Cookie 只能通过被 **HTTPS** 协议加密过的请求发送给服务端。即便设置了 Secure 标记，敏感信息也不应该通过 Cookie 传输，因为 Cookie 有其固有的不安全性，Secure 标记也无法提供确实的安全保障。
#### ⑦ Session
除了可以将用户信息通过**Cookie 存储**在用户**浏览器**中，也可以利用**Session 存储在服务器端**，存储在服务器端的信息更加安全。Session 可以存储在服务器上的**文件、数据库或者内存**中。也可以将 Session 存储在**Redis** 这种内存型数据库中，效率会更高。

使用 Session 维护用户登录状态的过程如下：
- 用户进行登录时，用户提交包含用户名和密码的表单，放入HTTP**请求报文**中；
- 服务器验证该用户名和密码，如果正确则把用户信息存储到**Redis** 中，它在 Redis 中的 Key 称为**Session ID**；
- 服务器返回的响应报文的**Set-Cookie**首部字段包含了这个**Session ID**，客户端收到响应报文之后将该Cookie值**存入浏览器**中；
- 客户端之后对同一个服务器进行请求时会包含该**Cookie**值，服务器收到之后提取出**Session ID**，从 Redis 中取出用户信息，继续之前的业务操作。
#### ⑧ 浏览器禁用 Cookie
此时无法使用 Cookie 来保存用户信息而**只能使用 Session**。除此之外，不能再将 Session ID 存放到 Cookie 中，而是使用**URL 重写技术**，将 Session ID**作为 URL 的参数进行传递**。
#### ⑨ Cookie与Session选择
Cookie 和 Session**都是用来跟踪浏览器用户身份的会话方式**，但是两者的应用场景不太一样。

Cookie一般用来保存用户信息,比如
1. 们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了
2. 一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)
3. 登录一次网站后访问网站其他页面不需要重新登录。**Session 的主要作用就是通过服务端记录用户的状态。** 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了

Cookie和Session对比:
- Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端
- Cookie 存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在 Cookie 中，可以将**Cookie 值进行加密**，然后在服务器进行解密
- 对于大型网站，如果用户所有的信息都存储在 Session 中，那么开销是非常大的，因此不建议将所有的用户信息都存储到 Session 中

### 7.6.5 缓存
#### ① 优点
- 缓解服务器压力；
- 降低客户端获取资源的延迟：缓存通常位于**内存**中，读取缓存的速度更快。并且缓存服务器在地理位置上也有可能比源服务器来得近，例如浏览器缓存。
#### ② 实现方法
- 让**代理服务器**进行缓存；
- 让**客户端浏览器**进行缓存。
#### ③ Cache-Control首部字段
HTTP/1.1 通过 **Cache-Control** 首部字段来控制缓存。
##### I 禁止进行缓存
**no-store** 指令规定**不能**对请求或响应的任何一部分进行缓存。**禁止缓存**
```http
Cache-Control: no-store
```
##### II 强制确认缓存
no-cache 指令规定缓存服务器需要先向源服务器验证缓存资源的有效性，只有当缓存资源有效时才能使用该缓存对客户端的请求进行响应
```http
Cache-Control: no-cache
```
##### III 私有缓存和公共缓存
- private 指令规定了将资源作为**私有缓存**，只能被单独用户使用，一般存储在**用户浏览器**中。
```http
Cache-Control: private
```
- public 指令规定了将资源作为**公共缓存**，可以被多个用户使用，一般存储在**代理服务器**中
```http
Cache-Control: public
```
##### IV 缓存过期机制
- **max-age** 指令出现在**请求报文**，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。
- **max-age** 指令出现在**响应报文**，表示缓存资源在缓存服务器中保存的时间。
```http
Cache-Control: max-age=31536000
```
- **Expires** 首部字段也可以用于告知缓存服务器该资源什么时候会过期。
```http
Expires: Wed, 04 Jul 2012 08:26:05 GMT
```
>在 HTTP/1.1 中，会优先处理 max-age 指令；在 HTTP/1.0 中，max-age 指令会被忽略掉。

#### ④ 缓存验证
**ETag** 首部字段的含义，它是资源的唯一标识。URL 不能唯一表示资源，例如 `http://www.google.com/` 有中文和英文两个资源，只有 **ETag** 才能对这两个资源进行**唯一标识**。
```
ETag: "82e22293907ce725faf67773957acd12"
```
可以将缓存资源的 ETag 值放入 **If-None-Match** 首部，服务器收到该请求后，判断缓存资源的 ETag 值和资源的最新 ETag 值是否一致，如果一致则表示缓存资源有效，返回 304 Not Modified。
```http
If-None-Match: "82e22293907ce725faf67773957acd12"
```
**Last-Modified** 首部字段也可以用于缓存验证，它包含在源服务器发送的响应报文中，指示源服务器对资源的最后修改时间。但是它是一种弱校验器，因为只能精确到一秒，所以它通常作为 ETag 的备用方案。如果响应首部字段里含有这个信息，客户端可以在后续的请求中带上 If-Modified-Since 来验证缓存。服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200 OK。如果请求的资源从那时起未经修改，那么返回一个不带有实体主体的 304 Not Modified 响应报文。
```http
Last-Modified: Wed, 21 Oct 2015 07:28:00 GMT
```
```http
If-Modified-Since: Wed, 21 Oct 2015 07:28:00 GMT
```
#### 7.6.6 内容协商
通过内容协商返回**最合适的内容**，例如根据浏览器的默认语言选择返回中文界面还是英文界面。
##### ① 类型
###### I 服务端驱动型
客户端设置特定的**HTTP 首部字段**，例如 Accept、Accept-Charset、Accept-Encoding、Accept-Language，服务器根据这些字段返回特定的资源。

存在以下问题：
- 服务器很难知道客户端浏览器的全部信息；
- 客户端提供的信息相当冗长（HTTP/2 协议的首部压缩机制缓解了这个问题），并且存在隐私风险（HTTP 指纹识别技术）
- 给定的资源需要返回不同的展现形式，共享缓存的效率会降低，而服务器端的实现会越来越复杂
###### II 代理驱动型
服务器返回 300 Multiple Choices 或者 406 Not Acceptable，客户端从中选出最合适的那个资源。
##### ② Vary
```html
Vary: Accept-Language
```
在使用内容协商的情况下，只有当缓存服务器中的缓存满足内容协商条件时，才能使用该缓存，否则应该向源服务器请求该资源。

例如，一个客户端发送了一个包含 Accept-Language 首部字段的请求之后，源服务器返回的响应包含 `Vary: Accept-Language` 内容，缓存服务器对这个响应进行缓存之后，在客户端下一次访问同一个 URL 资源，并且 Accept-Language 与缓存中的对应的值相同时才会返回该缓存。

#### 7.6.7 编码
##### ① 压缩传输的内容编码
内容编码将**实体主体**进行**压缩**，从而减少传输的数据量。请求首部不压缩

常用的内容编码有：gzip、compress、deflate、identity

浏览器发送 Accept-Encoding 首部，其中包含有它所支持的压缩算法，以及各自的优先级。服务器则从中选择一种，使用该算法对响应的消息主体进行压缩，并且发送 Content-Encoding 首部来告知浏览器它选择了哪一种算法。由于该内容协商过程是基于编码类型来选择资源的展现形式的，响应报文的 Vary 首部字段至少要包含 Content-Encoding。
##### ② 分块传输编码
Chunked Transfer Encoding，可以把数据分割成多块，让浏览器逐步显示页面。

#### 7.6.8 范围请求
如果网络出现中断，服务器只发送了一部分数据，范围请求可以使得客户端只请求服务器**未发送的那部分数据**，从而避免服务器重新发送所有数据。
##### ① Range
在请求报文中添加**Range**首部字段指定请求的**范围**。
```http
GET /z4d4kWk.jpg HTTP/1.1
Host: i.imgur.com
Range: bytes=0-1023
```
请求成功的话服务器返回的响应包含**206 Partial Content** 状态码。
```http
HTTP/1.1 206 Partial Content
Content-Range: bytes 0-1023/146515
Content-Length: 1024
...
(binary content)
```
##### ② Accept-Ranges
响应首部字段**Accept-Ranges**用于告知客户端是否能处理范围请求，可以**处理使用bytes**，否则使用**none**。
```http
Accept-Ranges: bytes
```
##### ③ 响应状态码
- 在请求成功的情况下，服务器会返回**206** Partial Content 状态码。
- 在请求的范围越界的情况下，服务器会返回**416** Requested Range Not Satisfiable 状态码。
- 在不支持范围请求的情况下，服务器会返回**200**OK 状态码。

#### 7.6.9 多部分对象集合
一份报文主体内可含有**多种类型**的实体同时发送，每个部分之间用**boundary**字段定义的分隔符进行分隔，每个部分都可以有首部字段。       
例如，上传多个表单时可以使用如下方式：
```html
Content-Type: multipart/form-data; boundary=AaB03x	// 指定Boundary

--AaB03x
Content-Disposition: form-data; name="submit-name"

Larry
--AaB03x
Content-Disposition: form-data; name="files"; filename="file1.txt"
Content-Type: text/plain

... contents of file1.txt ...
--AaB03x--
```

#### 7.7 HTTP/2.0
##### 7.7.1 HTTP/1.1新特性
- 默认是**长连接**
- 支持**流水线**
- 支持同时打开多个TCP连接
- 支持**虚拟主机**
- 新增状态码 100
- 支持**分块传输编码**3
- 新增缓存处理指令 max-age
##### 7.7.2 HTTP/1.x 缺陷
HTTP/1.x 实现简单是以牺牲性能为代价的：
- 客户端需要使用**多个连接**才能实现并发和缩短延迟；
- 不会压缩请求和响应首部,从而导致不必要的网络流量；
- 不支持有效的资源优先级，致使底层 TCP 连接的利用率低下。
##### 7.7.3 二进制分帧层
HTTP/2.0 将**报文**分成**HEADERS**帧和**DATA**帧，它们都是二进制格式的。

在通信过程中，只会有**一个 TCP 连接**存在，它承载了任意数量的**双向数据流(Stream)**
- 一个数据流（Stream）都有一个唯一标识符和可选的优先级信息，用于承载双向信息
- 消息（Message）是与逻辑请求或响应对应的完整的一系列帧
- 帧（Frame）是最小的通信单位，来自不同数据流的帧可以交错发送，然后再根据每个帧头的数据流标识符重新组装
##### 7.7.4 服务端推送
HTTP/2.0 在客户端请求一个资源时，会把相关的资源**一起**发送给客户端，客户端就不需要再次发起请求了。例如客户端请求 page.html 页面，服务端就把 script.js 和 style.css 等与之相关的资源一起发给客户端。
##### 7.7.5 首部压缩
HTTP/1.1 的首部带有大量信息，而且每次都要重复发送.HTTP/2.0 要求客户端和服务器同时维护和更新一个包含之前**见过的首部字段表**，从而避免了重复传输。不仅如此，HTTP/2.0 也使用**Huffman**编码对首部字段进行**压缩**。

## 7.8 GET和POST比较
### 7.8.1 作用
GET 用于获取资源，而 POST 用于传输实体主体。
### 7.8.2 参数
GET 和 POST 的请求都能使用**额外的参数**，但是 GET 的参数是以查询字符串出现在**URL**中，而 POST 的参数存储在**实体主体**中。不能因为 POST 参数存储在实体主体中就认为它的安全性更高，因为照样可以通过一些抓包工具（Fiddler）查看。

因为**URL**只支持**ASCII**码，因此 GET 的参数中如果存在中文等字符就需要先进行**编码**。例如 `中文` 会转换为 `%E4%B8%AD%E6%96%87`，而空格会转换为 `%20`。**POST** 参数支持**标准字符集**。
```
GET /test/demo_form.asp?name1=value1&name2=value2 HTTP/1.1
```
```
POST /test/demo_form.asp HTTP/1.1
Host: w3schools.com
name1=value1&name2=value2
```
### 7.8.3 安全
安全的 HTTP 方法不会改变服务器状态，也就是说它只是可读的。GET 方法是**安全**的，而 POST 却不是，因为 POST 的目的是传送实体主体内容，这个内容可能是用户上传的表单数据，上传成功之后，服务器可能把这个数据存储到数据库中，因此状态也就发生了改变。
- 安全的方法除了 GET 之外还有：HEAD、OPTIONS。
- 不安全的方法除了 POST 之外还有 PUT、DELETE。
### 7.8.4 幂等性
幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。

所有的**安全方法也都是幂等**的。在正确实现的条件下，**GET，HEAD，PUT 和 DELETE** 等方法都是**幂等**的，而 **POST** 方法**不是**。
### 7.8.5 可缓存
如果要对响应进行缓存，需要满足以下条件：
- 请求报文的**HTTP方法本身是可缓存**的，包括 GET 和 HEAD，但是 PUT 和 DELETE 不可缓存，POST 在多数情况下不可缓存的。
- 响应报文的**状态码是可缓存**的，包括：200, 203, 204, 206, 300, 301, 404, 405, 410, 414, and 501。
- 响应报文的 Cache-Control 首部字段没有指定不进行缓存。
### 7.8.6 XMLHttpRequest
为了阐述 POST 和 GET 的另一个区别，需要先了解 XMLHttpRequest：
>  XMLHttpRequest 是一个 API，它为客户端提供了在客户端和服务器之间传输数据的功能。它提供了一个通过 URL 来获取数据的简单方式，并且不会使整个页面刷新。这使得网页只更新一部分页面而不会打扰到用户。XMLHttpRequest 在 AJAX 中被大量使用。

- 在使用 XMLHttpRequest 的 POST 方法时，浏览器会先发送 Header 再发送 Data。但并不是所有浏览器会这么做，例如火狐就不会。
- 而 GET 方法 Header 和 Data 会一起发送。

### 7.8.9 总结
- GET 被强制服务器支持
- 浏览器对URL的长度有限制，所以GET请求不能代替POST请求发送大量数据
- GET请求发送数据更小
- GET请求是不安全的
- GET请求是幂等的
  - 幂等的意味着对同一URL的多个请求应该返回同样的结果
- POST请求不能被缓存
- POST请求相对GET请求是「安全」的
  - 这里安全的含义仅仅是指是非修改信息
- 这里安全的含义仅仅是指是非修改信息
  - 所谓安全的意味着该操作用于获取信息而非修改信息。换句话说，GET 请求一般不应产生副作用。就是说，它仅仅是获取资源信息，就像数据库查询一样，不会修改，增加数据，不会影响资源的状态。
- POST是用于修改服务器上的资源的请求
- 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠

**引申：说完原理性的问题，从表面上来看看GET和POST的区别：**
- GET是从服务器上获取数据，POST是向服务器传送数据。 GET和 POST只是一种传递数据的方式，GET也可以把数据传到服务器，他们的本质都是发送请求和接收结果。只是组织格式和数据量上面有差别，http协议里面有介绍
- GET是把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到。POST是通过HTTP POST机制，将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属性所指的URL地址。用户看不到这个过程。 因为GET设计成传输小数据，而且最好是不修改服务器的数据，所以浏览器一般都在地址栏里面可以看到，但POST一般都用来传递大数据，或比较隐私的数据，所以在地址栏看不到，能不能看到不是协议规定，是浏览器规定的。
- 对于GET方式，服务器端用Request.QueryString获取变量的值，对于POST方式，服务器端用Request.Form获取提交的数据。 没明白，怎么获得变量和你的服务器有关，和GET或POST无关，服务器都对这些请求做了封装  
- GET传送的数据量较小，不能大于2KB。POST传送的数据量较大，一般被默认为不受限制。但理论上，IIS4中最大量为80KB，IIS5中为100KB。 POST基本没有限制，我想大家都上传过文件，都是用POST方式的。只不过要修改form里面的那个type参数
- GET安全性非常低，POST安全性较高。 如果没有加密，他们安全级别都是一样的，随便一个监听器都可以把所有的数据监听到。

# 8. HTTPS
- HTTP：HyperText Transfer Protocol 超文本传输协议  
- HTTPS：Hypertext Transfer Protocol Secure 超文本传输安全协议  
- TLS：位于 HTTP 和 TCP 之间的协议，其内部有 TLS 握手协议、TLS 记录协议  
- HTTPS 经由 HTTP 进行通信，但利用**TLS 来保证安全**，即**HTTPS = HTTP + TLS**

## 8.1 HTTP和HTTPS的区别？
- 端口: HTTP 的 URL由“http://”起始且默认使用端口**80**，而 HTTPS 的 URL 由“https://”起始且默认使用端口**443**。
- 安全性和资源消耗：HTTP 协议运行在 TCP 之上，所有传输的内容都是**明文**，客户端和服务器端都**无法验证对方的身份**。HTTPS 是运行在**SSL/TLS** 之上的 HTTP 协议，**SSL/TLS 运行在TCP** 之上。所有传输的内容都经过**加密**，加密采用**对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密**。所以说，HTTP 安全性没有 HTTPS 高 ，但是 HTTPS 比 HTTP 耗费更多服务器资源。
  - 对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；
  - 非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。

## 8.2 HTTP的安全性问题
1. 使用**明文**进行通信，内容可能会被**窃听**；
2. 不验证通信方的身份，通信方的身份有可能遭遇**伪装**；
3. 无法证明报文的完整性，报文有可能遭**篡改**。

HTTPS 并不是新协议，而是让 HTTP 先**SSL**（Secure Sockets Layer）通信，再由**SSL 和 TCP** 通信，也就是说 HTTPS 使用了**隧道**进行通信。

通过使用 SSL，HTTPS 具有了**加密（防窃听）、认证（防伪装）和完整性保护（防篡改）** 。
**HTTP + 加密 + 认证 +  完整性保护 = HTTPS**     

## 8.3 加密
### 8.3.1 对称密钥加密
Symmetric-Key Encryption，加密和解密使用**同一密钥**。
- 优点：运算速度快；
- 缺点：无法安全地将**密钥**传输给通信方。

常用的对称加密算法：**AES**、3DES。
### 8.3.2 非对称密钥加密
非对称密钥加密，又称**公开密钥加密**（Public-Key Encryption），加密和解密使用**不同的密钥**。非对称加密一般有两种密钥，公钥和私钥，**公钥一般用于加密，私钥一般用于解密**。

常用的非对称加密算法：**RSA**（安全基于大质数的分解难度）、ECC、SM2 等。

公开密钥所有人都可以获得，**通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密**。

非对称密钥除了用来**加密**，还可以用来进行**签名**。因为私有密钥无法被其他人获取，因此通信发送方使用其**私有密钥进行签名**，通信接收方使用发送方的公开密钥**对签名进行解密**，就能判断这个签名是否正确。
- 优点：可以更安全地将公开密钥传输给通信发送方；
- 缺点：运算速度慢，消耗更多的资源。
### 8.3.3 HTTPS的加密方式
HTTPS 采用**混合的加密机制**，**在交换密钥环节使用非对称加密（公开密钥）方式 ，之后建立通信交换报文阶段（普通数据）则使用对称加密（共享密钥加密）方式**。

数据通信时需要用到一个**对称加密**的密钥，但是**直接**发过去是**不安全**的，所以使用**非对称加密**的方式将需要得**对称加密密钥**发送过去。

使用自己的私钥对自己所认可的消息生成一个该消息专属的签名，这就是**数字签名**，表明我承认该消息来自自己。注意：**私钥用于加签，公钥用于解签，每个人都可以解签，查看消息的归属人** 。

**公钥密码**也叫**非对称密码**，由**公钥和私钥**组成，它是最开始是为了解决秘钥的配送传输安全问题，即，我们不配送私钥，只配送公钥，私钥由本人保管。它与数字签名相反，公钥密码的私钥用于解密、公钥用于加密，每个人都可以用别人的公钥加密，但只有对应的私钥才能解开密文。  
- **client：明文 + 公钥 = 密文**  
- **server：密文 + 私钥 = 明文**

## 8.4 认证
当服务器接收到客户端发来的请求时，会向客户端发送服务器自己的公钥，但是**黑客有可能中途篡改公钥**，将其改成黑客自己的，所以有个问题，客户端怎么信赖这个公钥是自己想要访问的服务器的公钥而不是黑客的呢？所以客户端也需要对服务器发送过来的公钥认证其合法性。 这时候就需要用到**数字证书**。通过使用  **证书**  来对通信方进行认证。

数字证书认证机构（**CA**，Certificate Authority）是客户端与服务器双方**都可信赖**的第三方机构。
> 如何认证？
1. 首先阿里需要将自己的**公钥**发送给 CA 机构进行公钥申请，如果通过，则 CA 机构（CA 机构**自己也有公钥和私钥**）则利用其私钥对阿里的**公钥进行非对称加密**，这就是加密后的明文（**数字签名**）。加密完之后，得到的密文再加上证书的过期时间、颁发给、颁发者等信息，就组成了**数字证书**。（**数字证书就是数字签名加上各种附加信息**）
2. 用户浏览器向阿里发起 HTTPS 连接请求，阿里会将其**公钥 + 数字证书**发送给客户端。
3. 客户端首先需要对接收到的**公钥进行验证**，以确保公钥是真实的且没有被人篡改。不论什么平台，设备的操作系统中都会**内置** 100 多个全球公认的 **CA 的公钥**。所以客户端使用 **CA 机构的公钥对数字证书中的数字签名**进行**认证**：
  - 首先客户端会用设备中内置的 CA 的**公钥**尝试**解密数字证书**，如果所有内置的 CA 的公钥都**无法解密**该数字证书，说明该数字证书不是由一个全球知名的 CA 签发的，这样客户端就**无法信任**该服务器的**数字证书**。
  - 如果有一个 CA 的公钥能够成功**解密**该数字证书，说明该数字证书就是由该 CA 的私钥**签发**的，因为被私钥加密的密文只能被与其成对的公钥解密。
  - 除此之外，还需要检查客户端当前访问的服务器的域名是与数字证书中提供的“颁发给”这一项吻合，还要检查数字证书是否过期等。

只有通过**认证之后**才能继续后面的加密与通信步骤。进行 HTTPS 通信时，服务器会把**CA 证书**发送给**客户端**。客户端取得其中的**公开密钥**之后，先使用**数字签名**进行**验证**，如果验证通过，就可以开始通信了。

|    密码    |                作用                |           组成            |
| :--------: | :--------------------------------: | :-----------------------: |
| 消息认证码 | 确认消息的完整、并对消息的来源认证 |   共享秘钥+消息的散列值   |
|  数字签名  |         对消息的散列值签名         |  公钥+私钥+消息的散列值   |
|  公钥密码  |         解决秘钥的配送问题         |      公钥+私钥+消息       |
|    证书    |         解决公钥的归属问题         | 公钥密码中的公钥+数字签名 |

## 8.5 完整性保护
SSL 提供一种叫做**MAC**的**报文摘要**功能来进行**完整性保护**。

HTTP 也提供了**MD5**报文摘要功能，但不是安全的。例如报文内容被篡改之后，同时重新计算 MD5 的值，通信接收方是无法意识到发生了篡改。

HTTPS 的报文摘要功能之所以安全，是因为它结合了**加密和认证**这两个操作。试想一下，加密之后的报文，遭到篡改之后，也很难重新计算报文摘要，因为无法轻易获取明文。

## 8.6 HTTPS通信流程总结
- 服务器端的公钥和私钥，用来进行非对称加密。
- 客户端生成的随机密钥，用来进行对称加密。

一个 HTTPS 请求实际上包含了**两次 HTTP**传输，可以细分为 8 步:
1. 客户端向服务器发起**HTTPS 请求**，连接到服务器的**443 端口**。
2. 服务器端有一个密钥对，即**公钥和私钥**，是用来进行非对称加密使用的，**服务器端保存着私钥**，不能将其泄露，公钥可以发送给任何人。
3. 服务器将自己的**公钥发送给客户端**。
4. 客户端收到服务器端的公钥之后，会对**公钥进行检查**，验证其**合法性**，如果发现发现公钥有问题，那么 HTTPS 传输就无法继续。严格的说，这里应该是**验证服务器发送的数字证书的合法性**，如果**公钥合格**，那么**客户端**会生成一个**随机值**，这个随机值就是用于进行对称加密的**密钥**，我们将该密钥称之为 client key，即**客户端密钥**，这样在概念上和服务器端的密钥容易进行区分。然后用服务器的**公钥**对**客户端密钥进行非对称加密**，这样客户端密钥就变成密文了，至此，HTTPS 中的第一次 HTTP 请求结束。
5. 客户端会发起 HTTPS 中的**第二个**HTTP 请求，将**加密之后的客户端密钥发送给服务器**。
6. 服务器接收到客户端发来的密文之后，会用自己的**私钥**对其进行**非对称解密**，解密之后的明文就是**客户端密钥**，然后用客户端密钥对数据进行**对称加密**，这样数据就变成了**密文**。
7. 然后服务器将**加密后的密文**发送给客户端。
8. 客户端收到服务器发送来的密文，用客户端密钥对其进行对称解密，得到服务器发送的数据。这样 HTTPS 中的第二个 HTTP 请求结束，整个 HTTPS 传输完成。

## 8.7 HTTPS的缺点
- 因为需要进行**加密解密**等过程，对 CPU 的额外**开销较大**，因此速度会更慢；
- 需要支付证书授权的**高额费用**。

## 8.8 SSL与TLS
### 8.8.1 概述
TLS/SSL是一种**加密通道的规范**。

**SSL**：（Secure Socket Layer） 安全套接层，**TLS**：（Transport Layer Security）**传输层安全性协议**，是 IETF 在 SSL3.0 的**基础上**设计的协议。

在**发送方**，SSL 接收**应用层**的数据，对数据进行**加密**，然后把加了密的数据送往 **TCP 套接字**。在**接收方**，SSL 从 TCP 套接字**读取**数据，**解密** 后把数据交给应用层 。

该协议由两层组成： TLS 记录协议（TLS Record）和 TLS 握手协议（TLS Handshake）。较低的层为 TLS 记录协议，位于某个可靠的传输协议（例如 TCP）上面。

### 8.8.2 SSL/TLS 握手流程
SSL/TLS 握手是为了**安全**地协商出一份**对称加密**的秘钥

#### 1. client hello
握手第一步是客户端向服务端发送 Client Hello 消息，这个消息里包含了一个客户端生成的随机数 **Random1**、客户端支持的**加密套件**（Support Ciphers）和 SSL Version 等信息。
#### 2. server hello
第二步是服务端向客户端发送 Server Hello 消息，这个消息会从 Client Hello 传过来的 Support Ciphers 里确定一份加密套件，这个套件决定了后续加密和生成摘要时具体使用哪些算法，另外还会生成一份随机数 **Random2**。注意，至此客户端和服务端都拥有了两个随机数（Random1+ Random2），这两个随机数会在后续生成对称秘钥时用到。
#### 3. server certificate
这一步是服务端将自己的证书下发给客户端，让客户端验证自己的身份，客户端验证通过后取出证书中的公钥。
#### 4. Server Hello Done
Server Hello Done 通知客户端 Server Hello 过程结束。
#### 5. Client Key Exchange
上面客户端根据服务器传来的公钥生成了 **PreMaster Key**，Client Key Exchange 就是将这个 key 传给服务端，服务端再用自己的私钥解出这个 **PreMaster Key** 得到客户端生成的 **Random3**。至此，客户端和服务端都拥有 **Random1** + **Random2** + **Random3**，两边再根据同样的算法就可以生成一份秘钥，握手结束后的应用层数据都是使用这个秘钥进行对称加密。

为什么要使用三个随机数呢？这是因为 SSL/TLS 握手过程的数据都是明文传输的，并且多个随机数种子来生成秘钥不容易被暴力破解出来。
#### 6. Change Cipher Spec(Client)
这一步是客户端通知服务端后面再发送的消息都会使用前面协商出来的秘钥加密了，是一条事件消息。
#### 7. Finished(Client)
客户端发送Finished报文。该报文包含连接至今全部报文的整理校验值。这次握手协议是否能成功，要以服务器是否能够正确解密该报文作为判定标准。
#### 8. Change Cipher Spec(Server)
服务器同样发送Change Cipher Spec报文给客户端
#### 9. Finished(Server)
服务器同样发送Finished报文给客户端
#### 10-11. Application Data
到这里，双方已安全地协商出了同一份秘钥，所有的应用层数据都会用这个秘钥加密后再通过 TCP 进行可靠传输。
#### 12. Alert：warning, close notify
最后由客户端断开连接。断开连接时，发送close_notify报文。上图做了一些省略，在这步之后再发送一种叫做MAC（Message Authentication Code）的报文摘要。MAC能够查知报文是否遭到篡改，从而保护报文的完整性。

#### * demand client certificate
Certificate Request 是服务端要求客户端上报证书，这一步是可选的，对于安全性要求高的场景会用到。
#### * check server certificate

客户端收到服务端传来的证书后，先从 CA 验证该证书的合法性，验证通过后取出证书中的服务端公钥，再生成一个随机数 **Random3**，再用服务端公钥非对称加密 **Random3** 生成 **PreMaster Key**。

## 8.9 RSA
RSA 是一种**公钥密码算法**，我们简单的走一遍它的加密解密过程

**加密算法**：密文 = (明文^E) mod N，其中公钥为{E, N}，即求明文的 E 次方的对 N 的余数

**解密算法**：明文 = (密文^D) mod N，其中秘钥为{D, N}，即求密文的 D 次方的对 N 的余数

# 9. Socket与I/O
## 9.1 I/O 模型
通常用户进程中的一次**完整 IO 交互**流程分为**两个阶段**。
1. 首先是经过**内核空间**，也就是由操作系统处理
2. 紧接着到**用户空间**，由应用程序处理

必须通过系统调用请求 Kernel 协助完成 IO 操作

一个网络**输入操作**主要分为两个阶段：
1. **等待数据**：等待网络数据到达**网卡**，然后将**数据读取到内核缓冲区**
2. **复制数据**：从内核缓冲区**复制数据**，拷贝到用户空间的应用程序中

对于一个**套接字**上的输入操作，第一步通常涉及等待数据从网络中到达。当所等待数据到达时，它被复制到内核中的某个**缓冲区**。第二步就是把数据从内核缓冲区复制到应用进程缓冲区。

Unix 有**五种** I/O 模型：
- **阻塞式 I/O**(BIO)
- **非阻塞式 I/O**(NIO)
- **I/O 复用（select 和 poll）**
- **信号驱动式 I/O（SIGIO）**
- **异步 I/O（AIO）**

### 9.1.1 阻塞式 I/O
应用进程被**阻塞**，直到数据从**内核缓冲区**复制到应用**进程缓冲区中**才返回。

在阻塞的过程中，其它应用进程还可以执行，因此阻塞不意味着整个操作系统都被阻塞。因为其它应用进程还可以执行，所以不消耗 CPU 时间，这种模型的 CPU**利用率效率**会比较高。例如 Java BIO。
### 9.1.2 非阻塞式I/O
应用进程执行系统调用 **recvfrom**() 之后，内核返回一个**错误码**。应用进程可以继续执行，但是需要不断的执行系统调用来获知 I/O 是否完成，这种方式称为**轮询**（polling）。由于 CPU 要处理更多的**系统调用**，因此这种模型的 CPU 利用率比较**低**。
### 9.1.3 多路复用I/O★
使用 **select() 或者 poll()** 等待数据，并且可以**等待多个套接字**中的任何一个变为**可读**。这一过程会被**阻塞**，当某一个套接字可读时返回，之后再使用 **recvfrom** 把数据从内核**复制**到进程中，所以这里使用了**两个**系统调用。

它可以让**单个进程**具有处理**多个 I/O 事件**的能力。又被称为 Event Driven I/O，即**事件驱动 I/O**。

多个进程的 IO 可以注册到一个**Selector**上，Selector 会对所有的 IO 进行监听。

如果一个 Web 服务器没有 I/O 复用，那么**每一个 Socket 连接**都需要创建一个**线程**去处理。如果同时有几万个连接，那么就需要创建相同数量的线程。相比于多进程和多线程技术，**I/O 复用不需要进程线程创建和切换的开销**，系统开销更小。

IO 复用的**优势在于能够处理更多的连接**，对单个连接的处理不一定比阻塞 IO 快。

对于每一个 Socket，一般都是设置为非阻塞，但是**整个用户的进程其实是一直被阻塞**的，只不过进程是被 select 调用阻塞，而不是被 Socket IO 阻塞。

典型应用有 Java NIO、Nginx。
### 9.1.4 信号驱动I/O
应用进程使用 **sigaction** 系统调用，内核**立即**返回，应用进程可以继续执行，也就是说等待数据阶段应用进程是**非阻塞**的。内核在数据到达时向应用进程发送 **SIGIO** 信号，应用进程收到之后在信号处理程序中调用 **recvfrom** 调用将数据从内核复制到应用进程中。

相比于非阻塞式 I/O 的轮询方式，信号驱动 I/O 的 CPU 利用率更高。等待数据的时候不是阻塞的，但是**拷贝**数据到应用进程的时候**依然是阻塞**的。
### 9.1.5 异步I/O
应用进程执行**aio_read** 系统调用会立即返回，应用进程可以继续执行，不会被阻塞，内核会在所有操作**完成**之后向应用进程**发送信号**。

异步 I/O 与信号驱动 I/O 的区别在于，异步 I/O 的信号是通知应用进程**I/O 完成**，而信号驱动 I/O 的信号是通知应用进程**可以开始 I/O**，也就是之后的 IO 操作依然需要用户进程阻塞拷贝数据。

真正的实现了异步，是五种 IO 模型中**唯一的异步模型**。

典型应用：**Java7 AIO**，高性能服务器应用。
### 9.1.6 五大I/O模型比较
#### ① 同步与异步
- **同步 IO **调用一旦开始,调用者必须等到方法调用返回后，才能继续后续的行为。
- **异步 IO** 调用更像一个消息传递，一旦开始，方法调用就会立即返回，调用者就可以继续后续的操作。而，异步方法通常会在另外一个线程中，“真实”地执行着。整个过程，不会阻碍调用者的工作。
#### ② 阻塞与非阻塞
阻塞调用是指调用结果返回之前，当前线程会被挂起。函数只有在得到结果之后才会返回。非阻塞和阻塞的概念相对应，指在不能立刻得到结果之前，该函数不会阻塞当前线程，而会立刻返回。

> 举个生活例子
如果你想吃一份宫保鸡丁盖饭：
- **同步阻塞**：你到饭馆点餐，然后在那等着，还要一边喊：好了没啊！
- **同步非阻塞**：在饭馆点完餐，就去遛狗了。不过每过十分钟就打电话问饭店：好了没啊！
- **异步阻塞**：遛狗的时候，接到饭馆电话，说饭做好了，让您亲自去拿。
- **异步非阻塞**：饭馆打电话说，我们知道您的位置，一会给你送过来，安心遛狗就可以了。

**阻塞式 I/O、非阻塞式 I/O、I/O 复用和信号驱动 I/O 都是同步 I/O**，它们的主要区别在**第一个阶段**，因为**第二阶段**都是**阻塞调用 recvfrom 将数据从内核复制**到用户进程。

非阻塞式 I/O 、信号驱动 I/O 和异步 I/O 在第一阶段不会阻塞。
## 9.2 I/O复用★
**select/poll/epoll** 都是 **I/O 多路复用**的具体**实现**，select 出现的最早，之后是 poll，再是 epoll。
### 9.2.1 select
```c
int select(int n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout);
```
有三种类型的描述符类型：**readset、writeset、exceptset**，分别对应读、写、异常条件的描述符集合。fd_set 使用数组实现，数组大小使用 FD_SETSIZE 定义。

**timeout** 为超时参数，调用 select 会一直阻塞直到有描述符的事件到达或者等待的时间超过 timeout。

成功调用返回结果大于 0，出错返回结果为 -1，超时返回结果为 0。

### 9.2.2 poll
```c
int poll(struct pollfd *fds, unsigned int nfds, int timeout);
```
pollfd 使用**链表实现**。
### 9.2.3 select与poll比较
#### ① 功能
select 和 poll 的功能基本相同，不过在一些实现细节上有所不同:
- select 会**修改描述符**，而 poll 不会；
- **select** 的**描述符类型**使用**数组实现**，FD_SETSIZE 大小默认为 **1024**，因此默认只能监听 1024 个描述符。如果要监听更多描述符的话，需要修改 FD_SETSIZE 之后**重新编译**；而 **poll** 的**描述符类型**使用**链表实现**，没有描述符数量的限制；
- poll 提供了更多的**事件类型**，并且对描述符的**重复利用**上比 select 高。
- 如果一个线程对某个描述符调用了 select 或者 poll，另一个线程关闭了该描述符，会导致调用结果不确定。
#### ② 速度
select 和 poll 速度**都比较慢**。
- select 和 poll**每次调用**都需要将**全部描述符**从应用进程缓冲区复制到**内核**缓冲区。
- select 和 poll 的返回结果中没有声明哪些描述符已经准备好，所以如果返回值大于 0 时，应用进程都需要使用轮询的方式来找到 I/O 完成的描述符。
#### ③ 可移植性
几乎**所有的**系统都**支持 select**，但是只有**比较新的**系统支持 **poll**。
### 9.2.4 epoll
```c
int epoll_create(int size);
int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；
int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);
```
epoll_ctl() 用于向内核注册**新的**描述符或者是改变某个文件描述符的**状态**。已注册的描述符在内核中会被维护在一棵**红黑树**上，通过**回调函数**内核会将 I/O 准备好的**描述符**加入到一个**链表**中管理，进程调用 **epoll_wait**() 便可以得到**事件完成**的描述符。

**epoll 仅适用于LinuxOS**,比 select 和 poll 更加**灵活**而且**没有描述符数量限制**。

epoll 对多线程编程更有友好，一个线程调用了 epoll_wait() 另一个线程关闭了同一个描述符也不会产生像 select 和 poll 的不确定情况。
### 9.2.5 epoll工作模式
epoll 的描述符事件有两种触发模式：**LT**（level trigger）和 **ET**（edge trigger）。
#### ① LT模式
当 epoll_wait() 检测到**描述符事件到达**时，将此**事件通知进程**，进程可以**不立即**处理该事件，下次调用 epoll_wait() 会再次通知进程。是默认的一种模式，并且同时支持 Blocking 和 No-Blocking。
#### ② ET模式
和 LT 模式不同的是，通知之后进程**必须立即处理事件**，下次再调用 epoll_wait() 时不会再得到事件到达的通知。

很大程度上减少了 epoll 事件被重复触发的次数，因此效率要比 LT 模式高。只支持 No-Blocking，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。
### 9.2.6 应用场景
很容易产生一种错觉认为只要用 epoll 就可以了，select 和 poll 都已经过时了，其实它们都有各自的使用场景。
#### ① select应用场景
- select 的 timeout 参数精度为 1ns，而 poll 和 epoll 为 1ms，因此**select 更加适用于实时性要求比较高**的场景，比如核反应堆的控制。
- **select 可移植性更好**，几乎被所有主流平台所支持。
#### ② poll应用场景
poll**没有最大描述符数量的限制**，如果**平台支持**并且对实时性要求不高，应该使用**poll**而非 select。
#### ③ epoll应用场景
- 只需要运行在**Linux**平台上，有**大量的描述符**需要同时轮询，并且这些连接最好是**长连接**。
- 需要同时监控**小于1000** 个描述符，就**没有必要**使用 epoll，因为这个应用场景下并不能体现 epoll 的优势。
- 需要监控的描述符状态**变化多**，而且都是非常短暂的，也**没有必要**使用 epoll。因为 epoll 中的所有描述符都存储在内核中，造成每次需要对描述符的状态改变都需要通过 epoll_ctl() 进行系统调用，频繁系统调用降低效率。并且 epoll 的描述符存储在内核，不容易调试。
